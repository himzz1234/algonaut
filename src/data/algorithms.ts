export interface AlgorithmMeta {
  id: string;
  name: string;
  category: string;
  description: string;
  shortDescription: string;
  complexities: {
    best: string;
    average: string;
    worst: string;
    space: string;
  };
  pseudocode?: string[];
  href?: string;
  tags?: string[];
  difficulty?: "beginner" | "intermediate" | "advanced";
  effort?: string;
}

export const algorithms: Record<string, AlgorithmMeta> = {
  "bubble-sort": {
    id: "bubble-sort",
    name: "Bubble Sort",
    category: "sorting",
    description:
      "Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It continues until the array is sorted.",
    shortDescription: "Simple sort by swapping adjacent elements.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "function bubbleSort(arr):",
      "    repeat until no swaps:",
      "        for i from 0 to n-2:",
      "            if arr[i] > arr[i+1]:",
      "               swap(arr[i], arr[i+1])",
      "    return arr",
    ],
    href: "/learn/sorting?algorithm=bubble-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Stable"],
  },
  "selection-sort": {
    id: "selection-sort",
    name: "Selection Sort",
    category: "sorting",
    description:
      "Selection Sort repeatedly selects the smallest element from the unsorted portion and swaps it with the first unsorted element, expanding the sorted portion one step at a time.",
    shortDescription: "Repeatedly selects the smallest element.",
    complexities: {
      best: "O(N²)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "function selectionSort(arr):",
      "    for i from 0 to n-1:",
      "        set minIndex = i",
      "        for j from i+1 to n-1:",
      "            if arr[j] < arr[minIndex]:",
      "               minIndex = j",
      "        swap(arr[i], arr[minIndex])",
      "    return arr",
    ],
    href: "/learn/sorting?algorithm=selection-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["In-place", "Unstable"],
  },
  "insertion-sort": {
    id: "insertion-sort",
    name: "Insertion Sort",
    category: "sorting",
    description:
      "Insertion Sort builds the sorted array one element at a time by repeatedly inserting the current element into its correct position among the already-sorted elements.",
    shortDescription: "Builds sorted array one item at a time.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "function insertionSort(arr):",
      "    for i from 1 to n-1:",
      "        key = arr[i]; j = i - 1",
      "        while j >= 0:",
      "           if arr[j] > key:",
      "             arr[j+1] = arr[j], j--",
      "        arr[j+1] = key",
      "    return arr",
    ],
    href: "/learn/sorting?algorithm=insertion-sort",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Stable", "Online"],
  },
  "merge-sort": {
    id: "merge-sort",
    name: "Merge Sort",
    category: "sorting",
    description:
      "Merge Sort is a divide-and-conquer algorithm. It recursively splits the array into halves, sorts each half, and then merges the sorted halves back together.",
    shortDescription: "Splits array and merges sorted halves.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N log N)",
      space: "O(N)",
    },
    pseudocode: [
      "function merge(arr, l, r):",
      "    if l >= r: return",
      "    mid = (l + r) // 2",
      "    mergeSort(arr, l, mid)",
      "    mergeSort(arr, mid + 1, r)",
      "    merged = []",
      "    i = l, j = mid + 1",
      "    while i <= mid and j <= r:",
      "        if arr[i] <= arr[j]:",
      "            merged.push(arr[i]); i++",
      "        else:",
      "            merged.push(arr[j]); j++",
      "    while i <= mid:",
      "        merged.push(arr[i]); i++",
      "    while j <= r:",
      "        merged.push(arr[j]); j++",
      "    copy merged back into arr[l..r]",
      "    return",
      "function mergeSort(arr):",
      "    mergeSort(arr, 0, n - 1)",
    ],
    href: "/learn/sorting?algorithm=merge-sort",
    difficulty: "intermediate",
    effort: "Medium–High",
    tags: ["Divide & Conquer", "Stable", "Recursion"],
  },
  "quick-sort": {
    id: "quick-sort",
    name: "Quick Sort",
    category: "sorting",
    description:
      "Quick Sort is a divide-and-conquer algorithm. It picks a pivot and partitions the array around the pivot, recursively sorting the partitions.",
    shortDescription: "Divide-and-conquer sorting using a pivot.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N²)",
      space: "O(log N)",
    },
    pseudocode: [
      "function quickSort(arr, left, right):",
      "    if left >= right: return",
      "    pivotIndex = partition(arr, left, right)",
      "    quickSort(arr, left, pivotIndex - 1)",
      "    quickSort(arr, pivotIndex + 1, right)",
      "    return arr",
    ],
    href: "/learn/sorting?algorithm=quick-sort",
    difficulty: "intermediate",
    effort: "High",
    tags: ["Divide & Conquer", "Recursion", "In-place"],
  },
  "linear-search": {
    id: "linear-search",
    name: "Linear Search",
    category: "searching",
    description:
      "Linear Search scans each element in the array sequentially until the target is found or the end of the array is reached.",
    shortDescription: "Scans elements sequentially for target.",
    complexities: {
      best: "O(1)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function linearSearch(arr, target):",
      "    for i from 0 to n - 1:",
      "        if arr[i] == target:",
      "            return i",
      "    return -1",
    ],
    href: "/learn/searching?algorithm=linear-search",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Sequential"],
  },
  "binary-search": {
    id: "binary-search",
    name: "Binary Search",
    category: "searching",
    description:
      "Binary Search repeatedly divides the search interval in half. It compares the target with the middle element and eliminates half of the array each step, until the element is found or the interval is empty.",
    shortDescription: "Halves search space to find target fast.",
    complexities: {
      best: "O(1)",
      average: "O(log N)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "function binarySearch(arr, target):",
      "    left = 0, right = n - 1",
      "    while left <= right:",
      "        mid = (left + right) / 2",
      "        if arr[mid] == target:",
      "            return mid",
      "        else if arr[mid] > target:",
      "            right = mid - 1",
      "        else:",
      "            left = mid + 1",
      "    return -1",
    ],
    href: "/learn/searching?algorithm=binary-search",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Divide & Conquer", "Efficient"],
  },
  "find-min-max": {
    id: "find-min-max",
    name: "Find Min & Max",
    category: "array",
    description:
      "The Min-Max algorithm scans through the array once, keeping track of the smallest and largest elements seen so far. At each step, it compares the current element with the current min and max and updates them if necessary. This ensures both values are found in a single pass.",
    shortDescription: "Finds smallest and largest element in one scan.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function findMinMax(arr):",
      "    set min = arr[0], max = arr[0]",
      "    for i from 1 to n - 1:",
      "        if arr[i] < min: min = arr[i]",
      "        else if arr[i] > max: max = arr[i]",
      "    return (min, max)",
    ],
    href: "/learn/array?algorithm=find-min-max",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linear Scan", "Basic", "Array"],
  },
  "reverse-array": {
    id: "reverse-array",
    name: "Reverse Array",
    category: "array",
    description:
      "Reverse Array swaps elements from both ends moving toward the center. It uses a two-pointer approach where one pointer starts at the beginning and another at the end, swapping until they meet. This reverses the array in-place.",
    shortDescription: "Reverses an array in-place using two pointers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function reverse(arr):",
      "    i = 0, j = n - 1",
      "    while i < j:",
      "        swap arr[i] and arr[j]",
      "        i++, j--",
      "    return arr",
    ],
    href: "/learn/array?algorithm=reverse-array",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Two Pointers", "In-place", "Array"],
  },
  "rotate-array": {
    id: "rotate-array",
    name: "Rotate Array by K steps",
    category: "array",
    description:
      "Rotate Array shifts elements in the array by a given number of steps. Each element is moved to a new position based on the rotation count, and the array is adjusted so that the order of elements wraps around. This results in the array being rotated to the left or right depending on the direction of rotation.",
    shortDescription: "Rotates an array by k steps, wrapping elements around.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function rotate(arr, k):",
      "    for r from 0 to k-1:",
      "        temp = arr[0]",
      "        for j from 1 to n-1:",
      "            arr[j-1] = arr[j]",
      "        arr[n-1] = temp",
      "    return arr",
    ],
    href: "/learn/array?algorithm=rotate-array",
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Array", "Rotation", "Two Pointers"],
  },
  kadane: {
    id: "kadane",
    name: "Kadane's Algorithm",
    category: "array",
    description:
      "Kadane's Algorithm finds the maximum sum of any contiguous subarray. It keeps track of a running sum (current sum) and resets it when it becomes worse than starting fresh. The best sum found so far is updated whenever the running sum is greater.",
    shortDescription: "Finds max sum of a contiguous subarray.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function kadane(arr):",
      "    n = length(arr)",
      "    sum = arr[0], max = arr[0]",
      "    for i from 1 to n-1:",
      "        if sum + arr[i] >= arr[i]:",
      "            sum = sum + arr[i]",
      "        else:",
      "            sum = arr[i]",
      "        if sum > max:",
      "            max = sum",
      "    return max",
    ],
    href: "/learn/array?algorithm=kadane",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Dynamic Programming", "Subarray", "Efficient"],
  },
  "prefix-sum": {
    id: "prefix-sum",
    name: "Prefix Sum Array",
    category: "array",
    description:
      "Pre-compute cumulative sums of an array to answer range sum queries efficiently.",
    shortDescription: "Precomputes cumulative sums for fast queries.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N)",
    },
    difficulty: "beginner",
    effort: "Low–Medium",
  },
  "max-sum-subarray-k": {
    id: "max-sum-subarray-k",
    name: "Max Sum Subarray of Size K",
    category: "Sliding Window",
    description:
      "Find the maximum sum of any contiguous subarray of size k. This is the simplest and most common use case of a fixed-size sliding window.",
    shortDescription: "Compute max sum of all subarrays of fixed size k.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(1)",
    },
    pseudocode: [
      "function maxSumSubarrayK(arr, k):",
      "    sum = sum of first k elements",
      "    maxSum = sum",
      "    for right from k to n-1:",
      "       sum += arr[right] - arr[right-k]",
      "        if sum > maxSum:",
      "            maxSum = sum",
      "    return maxSum",
    ],

    href: "/learn/sliding-window?algorithm=max-sum-subarray-k",
    tags: ["array", "sliding-window", "fixed-size"],
    difficulty: "beginner",
    effort: "Easy",
  },
  "smallest-subarray-with-sum-greater-than-k": {
    id: "smallest-subarray-with-sum-greater-than-k",
    name: "Smallest Subarray with Sum ≥ K",
    category: "Sliding Window",
    description:
      "Find the length of the smallest contiguous subarray whose sum is greater than or equal to K. This introduces the shrinking window pattern.",
    shortDescription: "Find minimum window length with sum ≥ K.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(1)",
    },
    pseudocode: [
      "function smallestSubWithSum(arr, k):",
      "    start = 0, currSum = 0, minLen = ∞",
      "    for end from 0 to n-1:",
      "        currSum += arr[end]",
      "        while currSum > k:",
      "            minLen = min(minLen, end - start + 1)",
      "            currSum -= arr[start]",
      "            start++",
      "    return minLen (or 0 if not found)",
    ],
    href: "/learn/sliding-window?algorithm=smallest-subarray-with-sum-greater-than-k",
    tags: ["array", "sliding-window", "variable-size"],
    difficulty: "beginner",
    effort: "Easy",
  },
  "longest-substring-without-repeat": {
    id: "longest-substring-without-repeat",
    name: "Longest Substring Without Repeating Characters",
    category: "Sliding Window",
    description:
      "Find the length of the longest substring without any repeating characters. This introduces hash maps or sets to track window content dynamically.",
    shortDescription: "Find longest substring with all unique characters.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(min(n, set))",
    },
    pseudocode: [
      "function longestUniqueSubstr(str):",
      "    start = 0, maxLen = 0, seen = {}",
      "    for end from 0 to n-1:",
      "        if str[end] in seen and seen[str[end]] >= start:",
      "            start = seen[str[end]] + 1",
      "        seen[str[end]] = end",
      "        if (end - start + 1) > maxLen:",
      "            maxLen = end - start + 1",
      "    return maxLen",
    ],

    href: "/learn/sliding-window?algorithm=longest-substring-without-repeat",
    tags: ["string", "sliding-window", "hash-set"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  factorial: {
    id: "factorial",
    name: "Factorial (Stack View)",
    category: "recursion",
    description:
      "Factorial is defined recursively: n! = n × (n-1)! with base case 0! = 1. Recursion demonstrates the call stack as it unwinds.",
    shortDescription: "Compute factorial using recursion and stack frames.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N)",
    },
    pseudocode: [
      "function factorial(n):",
      "    if n <= 1:",
      "        return 1",
      "    sub = factorial(n - 1)",
      "    result = n * sub",
      "    return result",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/recursion?algorithm=factorial",
    tags: ["Recursion", "Stack", "Math"],
  },
  fibonacci: {
    id: "fibonacci",
    name: "Fibonacci (Recursion Tree)",
    category: "recursion",
    description:
      "Fibonacci numbers follow the recurrence F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Recursive calls expand into a tree structure, illustrating exponential growth.",
    shortDescription: "Recursive definition of Fibonacci sequence.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N)",
    },
    pseudocode: [
      "function fib(n):",
      "    if n <= 1:",
      "        return n",
      "    result = fib(n - 1) + fib(n - 2)",
      "    return result",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    href: "/learn/recursion?algorithm=fibonacci",
    tags: ["Recursion", "Tree", "Math"],
  },
  "sum-n": {
    id: "sum-n",
    name: "Sum of First N Numbers",
    category: "recursion",
    description:
      "Sum of the first N natural numbers using recursion: S(n) = n + S(n-1), with base case S(0) = 0.",
    shortDescription: "Recursive summation of first N numbers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N)",
    },
    pseudocode: [
      "function sum(n):",
      "    if n <= 1:",
      "        return n",
      "    sub = sum(n - 1)",
      "    result = n + sub",
      "    return result",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/recursion?algorithm=sum-n",
    tags: ["Recursion", "Math", "Pattern"],
  },
  "tower-of-hanoi": {
    id: "tower-of-hanoi",
    name: "Tower of Hanoi",
    category: "recursion",
    description:
      "Tower of Hanoi is a classic puzzle solved recursively: move n-1 disks to auxiliary, move the largest disk to target, then move n-1 disks from auxiliary to target.",
    shortDescription: "Recursive disk-moving puzzle solution.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function hanoi(n, source, target, auxiliary):",
      "    if n == 1:",
      "        move disk from source → target",
      "        return",
      "    hanoi(n-1, source, auxiliary, target)",
      "    move disk from source → target",
      "    hanoi(n-1, auxiliary, target, source)",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Recursion", "Puzzle", "Divide & Conquer"],
  },
  "reverse-string": {
    id: "reverse-string",
    name: "Reverse String (Recursive)",
    category: "recursion",
    description:
      "Reverse a string recursively by reducing the problem: reverse the substring after the first character, then append the first character to the result.",
    shortDescription: "Recursively reverse a string.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack + new string)",
    },
    pseudocode: [
      "function reverse(s):",
      "    if length of s <= 1:",
      "        return s",
      "    return reverse(s[1:]) + s[0]",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "String", "Divide & Conquer"],
  },
  "check-odd-even": {
    id: "check-odd-even",
    name: "Check if Number is Odd or Even",
    category: "bitmask",
    description:
      "Use bitwise AND with 1 to check if a number is odd or even. If the least significant bit is 1, the number is odd; otherwise, it is even.",
    shortDescription: "Check odd/even using least significant bit.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function checkOddEven(n):",
      "    look at the least significant bit (n & 1)",
      "    if (n & 1) == 1:",
      "        return 'odd'",
      "    else:",
      "        return 'even'",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=check-odd-even",
    tags: ["Bits", "Odd/Even", "Trick"],
  },
  "get-ith-bit": {
    id: "get-ith-bit",
    name: "Get i-th Bit",
    category: "bitmask",
    description:
      "Check if the i-th bit of a number is set (1) or not (0) using a mask.",
    shortDescription: "Check if i-th bit is 1.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function getIthBit(n, i):",
      "    mask = 1 << i",
      "    if (n & mask) != 0:",
      "        return true",
      "    else:",
      "        return false",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=get-ith-bit",
    tags: ["Bits", "Masking", "Check"],
  },
  "set-ith-bit": {
    id: "set-ith-bit",
    name: "Set i-th Bit",
    category: "bitmask",
    description: "Turn the i-th bit of a number to 1 using OR with a mask.",
    shortDescription: "Force i-th bit to 1.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function setIthBit(n, i):",
      "    mask = 1 << i",
      "    n = n | mask",
      "    return n",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=set-ith-bit",
    tags: ["Bits", "Masking", "Set"],
  },
  "clear-ith-bit": {
    id: "clear-ith-bit",
    name: "Clear i-th Bit",
    category: "bitmask",
    description:
      "Turn the i-th bit of a number to 0 using AND with the inverse of a mask.",
    shortDescription: "Force i-th bit to 0.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function clearIthBit(n, i):",
      "    mask = 1 << i",
      "    mask = ~mask",
      "    n = n & mask",
      "    return n",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=clear-ith-bit",
    tags: ["Bits", "Masking", "Clear"],
  },
  "toggle-ith-bit": {
    id: "toggle-ith-bit",
    name: "Toggle i-th Bit",
    category: "bitmask",
    description: "Flip the i-th bit of a number using XOR with a mask.",
    shortDescription: "Flip i-th bit (0→1 or 1→0).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function toggleIthBit(n, i):",
      "    mask = 1 << i",
      "    n = n ^ mask",
      "    return n",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=toggle-ith-bit",
    tags: ["Bits", "Masking", "Toggle"],
  },
  "count-set-bits": {
    id: "count-bits",
    name: "Count Set Bits",
    category: "bitmask",
    description:
      "Count the number of 1 bits in an integer using Brian Kernighan’s algorithm: repeatedly clear the lowest set bit until the number becomes zero.",
    shortDescription: "Count 1s in binary representation.",
    complexities: {
      best: "O(k), k = set bits",
      average: "O(k)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "function countSetBits(n):",
      "    count = 0",
      "    while n > 0:",
      "        if (n & 1) == 1:",
      "            count++",
      "        n = n >> 1",
      "    return count",
    ],
    difficulty: "intermediate",
    href: "/learn/bitmask?algorithm=count-set-bits",
    effort: "Medium",
    tags: ["Bits", "Kernighan", "Counting"],
  },
  "power-of-two": {
    id: "power-of-two",
    name: "Check if Number is Power of Two",
    category: "bitmask",
    description:
      "A number is a power of two if it has exactly one set bit. This can be checked with n > 0 and n & (n-1) == 0.",
    shortDescription: "Check power-of-two using bit trick.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function powerOfTwo(n):",
      "    if (n & (n - 1)) == 0 and n > 0:",
      "        return true",
      "    else:",
      "        return false",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=power-of-two",
    tags: ["Bits", "Power of Two", "Trick"],
  },
  "lowest-set-bit": {
    id: "lowest-set-bit",
    name: "Get Lowest Set Bit",
    category: "bitmask",
    description:
      "Extract the lowest set bit of a number using the expression n & -n. Useful in Fenwick trees and subset generation.",
    shortDescription: "Isolate lowest set bit using n & -n.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["lowest = n & -n"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Trick", "Lowest Bit"],
  },
  "clear-lowest-set-bit": {
    id: "clear-lowest-set-bit",
    name: "Clear Lowest Set Bit",
    category: "bitmask",
    description:
      "Clear the lowest set bit of a number using n & (n-1). Commonly used for iterating through subsets efficiently.",
    shortDescription: "Clear lowest set bit using n & (n-1).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["n = n & (n - 1)"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Subset Iteration", "Trick"],
  },
  subsets: {
    id: "subsets",
    name: "Subsets (Power Set)",
    category: "backtracking",
    description:
      "Generate all possible subsets (the power set) of a given array using recursion and backtracking.",
    shortDescription: "Generate all subsets of an array.",
    complexities: {
      best: "O(2^n)",
      average: "O(2^n)",
      worst: "O(2^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(start, path):",
      "    add copy of path to result",
      "    for i from start to n-1:",
      "        path.push(nums[i])",
      "        backtrack(i + 1, path)",
      "        path.pop()",
      "function subsets(nums):",
      "    result = []",
      "    backtrack(0, [])",
      "    return result",
    ],

    href: "/learn/backtracking?algorithm=subsets",
    tags: ["array", "backtracking", "recursion", "power-set"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  permutations: {
    id: "permutations",
    name: "Permutations",
    category: "backtracking",
    description:
      "Generate all possible permutations of a given array using recursion and backtracking.",
    shortDescription: "Generate all permutations of an array.",
    complexities: {
      best: "O(n!)",
      average: "O(n!)",
      worst: "O(n!)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(path, used):",
      "    if path.length == n:",
      "        add copy of path to result",
      "        return",
      "    for i in 0..n-1:",
      "        if used[i]: continue",
      "        path.push(nums[i]); used[i] = true",
      "        backtrack(path, used)",
      "        path.pop(); used[i] = false",
      "function permutations(nums):",
      "    result = []",
      "    backtrack([], [false]*n)",
      "    return result",
    ],

    href: "/learn/backtracking?algorithm=permutations",
    tags: ["array", "backtracking", "recursion", "permutations"],
    difficulty: "intermediate",
    effort: "Medium–High",
  },
  "combination-sum": {
    id: "combination-sum",
    name: "Combination Sum",
    category: "backtracking",
    description:
      "Find all unique combinations of candidates where the chosen numbers sum to a target. Numbers can be reused multiple times.",
    shortDescription: "Generate all combinations with sum = target.",
    complexities: {
      best: "O(2^n)",
      average: "O(2^n)",
      worst: "O(2^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(start, remaining, path):",
      "    if remaining == 0:",
      "        add copy of path to result",
      "        return",
      "    for i in range(start, n):",
      "        if arr[i] > remaining: break",
      "        path.push(arr[i])",
      "        backtrack(i, remaining - arr[i], path)",
      "        path.pop()",
      "function combinationSum(arr, target):",
      "    result = []",
      "    backtrack(0, target, [])",
      "    return result",
    ],
    href: "/learn/backtracking?algorithm=combination-sum",
    tags: ["array", "backtracking", "recursion", "pruning"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  "n-queens": {
    id: "n-queens",
    name: "N-Queens",
    category: "backtracking",
    description:
      "Place N queens on an N×N chessboard so that no two queens threaten each other. Classic constraint-satisfaction problem.",
    shortDescription: "Place N queens on the board safely.",
    complexities: {
      best: "O(N!)",
      average: "O(N!)",
      worst: "O(N!)",
      space: "O(N)",
    },
    pseudocode: [
      "function nQueens(grid, n):",
      "    result = []",
      "    function isSafe(row, col):",
      "        for i = row-1 down to 0:",
      "            if grid[i][col] has queen: return false",
      "        for (i=row-1, j=col-1) down to 0:",
      "            if grid[i][j] has queen: return false",
      "        for (i=row-1, j=col+1) down to 0 and j<n:",
      "            if grid[i][j] has queen: return false",
      "        return true",
      "    function placeQueens(row):",
      "        if row == n:",
      "            add current board to result",
      "            return",
      "        for col = 0 to n-1:",
      "            if isSafe(row, col):",
      "                place queen at (row, col)",
      "                placeQueens(row + 1)",
      "                remove queen at (row, col)",
      "    placeQueens(0)",
      "    return result",
    ],
    tags: ["matrix", "backtracking", "recursion", "constraints"],
    difficulty: "intermediate",
    href: "/learn/backtracking?algorithm=n-queens",
    effort: "High",
  },
  "rat-in-a-maze": {
    id: "rat-in-a-maze",
    name: "Rat in a Maze",
    category: "backtracking",
    description:
      "Find a path for a rat to reach the destination in a maze represented by a grid. The rat can move only through open cells (1s) and cannot pass through walls (0s).",
    shortDescription: "Help the rat find a path through the maze.",
    complexities: {
      best: "O(2^(N^2))",
      average: "O(2^(N^2))",
      worst: "O(2^(N^2))",
      space: "O(N^2)",
    },
    pseudocode: [
      "function ratInMaze(grid):",
      "    n = length of grid",
      "    path = []",
      "    visited = n×n array of false",
      "    function isSafe(x, y):",
      "        if (x or y out of bounds): return false",
      "        if grid[x][y] is blocked: return false",
      "        if visited[x][y] is true: return false",
      "        return true",
      "    function backtrack(x, y):",
      "        if isSafe(x, y):",
      "            mark visited[x][y] = true",
      "            add (x, y) to path",
      "            if (x, y) is destination:",
      "                add path to result",
      "                unmark visited[x][y]",
      "                remove (x, y) from path",
      "                return",
      "            for each direction in [down, right, up, left]:",
      "                backtrack(next x, next y)",
      "            unmark visited[x][y]",
      "            remove (x, y) from path",
      "        else: return",
      "    backtrack(0, 0)",
      "    return result",
    ],
    tags: ["matrix", "backtracking", "dfs", "pathfinding"],
    difficulty: "intermediate",
    href: "/learn/backtracking?algorithm=rat-in-a-maze",
    effort: "Medium",
  },
  "sudoku-solver": {
    id: "sudoku-solver",
    name: "Sudoku Solver",
    category: "backtracking",
    description:
      "Fill a 4×4 Sudoku board so that every row, column, and 2×2 sub-box contains digits 1 to 4 without repetition.",
    shortDescription: "Solve Sudoku using backtracking.",
    complexities: {
      best: "O(1)",
      average: "O(4^m)",
      worst: "O(4^m)",
      space: "O(m)",
    },
    pseudocode: [
      "function solveSudoku(grid):",
      "    row, col = findEmptyCell(grid)",
      "    if row == -1:",
      "        record solution",
      "        return true",
      "    for num = 1 to 4:",
      "        if isValid(grid, row, col, num):",
      "            grid[row][col] = num",
      "            if solveSudoku(grid):",
      "                return true",
      "            grid[row][col] = 0",
      "    return false",
      "function isValid(grid, row, col, num):",
      "    for c = 0 to 3:",
      "        if grid[row][c] == num: return false",
      "    for r = 0 to 3:",
      "        if grid[r][col] == num: return false",
      "    startRow = (row / 2) * 2",
      "    startCol = (col / 2) * 2",
      "    for r = 0 to 1:",
      "        for c = 0 to 1:",
      "            if grid[startRow + r][startCol + c] == num: return false",
      "    return true",
    ],
    tags: ["matrix", "backtracking", "constraint-satisfaction"],
    difficulty: "advanced",
    href: "/learn/backtracking?algorithm=sudoku-solver",
    effort: "Very High",
  },
  "letter-combinations-phone": {
    id: "letter-combinations-phone",
    name: "Letter Combinations of a Phone Number",
    category: "backtracking",
    description:
      "Given a string of digits from 2-9, return all possible letter combinations based on phone keypad mappings.",
    shortDescription: "Generate letter combinations for phone digits.",
    complexities: {
      best: "O(4^n)",
      average: "O(4^n)",
      worst: "O(4^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(index, path):",
      "    if index == len(digits):",
      "        add path to result",
      "        return",
      "    digit = digits[index]",
      "    letters = phoneMap[digit]",
      "    for each letter in letters:",
      "        path.push(letter)",
      "        backtrack(index + 1, path)",
      "        path.pop()",
      "function letterCombinations(digits):",
      "    if digits is empty: return []",
      "    backtrack(0, [])",
      "    return result",
    ],

    href: "/learn/backtracking?algorithm=letter-combinations-phone",
    tags: ["string", "backtracking", "recursion"],
    difficulty: "beginner",
    effort: "Easy–Medium",
  },
  "ll-insert-end": {
    id: "ll-insert-end",
    name: "Insert at End (Singly List)",
    category: "linkedlist",
    description:
      "Given only the head pointer, traverse to the tail and attach a new node there. This runs in O(N).",
    shortDescription: "Traverse to tail and link new node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function insertAtEnd(head, value):",
      "    if head is null: return new Node(value)",
      "    curr = head",
      "    while curr.next is not null:",
      "        curr = curr.next",
      "    newNode = new Node(value)",
      "    curr.next = newNode",
      "    return head",
    ],
    href: "/learn/linkedlist?algorithm=ll-insert-end",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Linked List", "Singly", "Pointers", "Insertion"],
  },
  "ll-reverse": {
    id: "ll-reverse",
    name: "Reverse a Linked List (Singly)",
    category: "linkedlist",
    description:
      "Reverse the order of nodes in a singly linked list by re-wiring each node’s next pointer.",
    shortDescription: "Reverse a singly linked list in-place.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function reverseList(head):",
      "    prev = null",
      "    curr = head",
      "    while curr is not null:",
      "        next = curr.next",
      "        curr.next = prev",
      "        prev = curr",
      "        curr = next",
      "    head = prev",
      "    return head",
    ],
    href: "/learn/linkedlist?algorithm=ll-reverse",
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Reversal"],
  },
  "ll-cycle-detect-floyd": {
    id: "ll-cycle-detect-floyd",
    name: "Cycle Detection (Floyd's Algorithm)",
    category: "linkedlist",
    description:
      "Detect whether a cycle exists in a singly linked list using Floyd’s cycle-finding algorithm (tortoise and hare).",
    shortDescription: "Use two pointers (slow/fast) to detect a cycle.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function hasCycle(head):",
      "    slow = head",
      "    fast = head",
      "    while fast != null and fast.next != null:",
      "        slow = slow.next",
      "        fast = fast.next.next",
      "        if slow == fast:",
      "            return true",
      "    return false",
    ],
    href: "/learn/linkedlist?algorithm=ll-cycle-detect-floyd",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Cycle Detection", "Floyd"],
  },
  "ll-merge-two-sorted": {
    id: "ll-merge-two-sorted",
    name: "Merge Two Sorted Lists (Singly)",
    category: "linkedlist",
    description:
      "Given two singly linked lists sorted in ascending order, merge them into a single sorted list by rearranging pointers in-place.",
    shortDescription: "Merge two sorted linked lists in-place.",
    complexities: {
      best: "O(N + M)",
      average: "O(N + M)",
      worst: "O(N + M)",
      space: "O(1)",
    },
    pseudocode: [
      "function mergeTwoSorted(head1, head2):",
      "    if head1 == null: return head2",
      "    if head2 == null: return head1",
      "    prev1 = null; curr1 = head1; curr2 = head2",
      "    while curr1 != null and curr2 != null:",
      "        if curr1.value <= curr2.value:",
      "            prev1 = curr1",
      "            curr1 = curr1.next",
      "        else:",
      "            link prev1 to curr2",
      "            head1 = curr2 if prev1 == null",
      "            next2 = curr2.next",
      "            curr2.next = curr1",
      "            prev1 = curr2",
      "            curr2 = next2",
      "    if curr2 != null:",
      "        prev1.next = curr2",
      "    return head1",
    ],
    href: "/learn/linkedlist?algorithm=ll-merge-two-sorted",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Merge", "Two Pointers"],
  },
  "ll-middle-node": {
    id: "ll-middle-node",
    name: "Find Middle Node (Singly)",
    category: "linkedlist",
    description:
      "Find the middle node of a singly linked list using the slow–fast pointer technique.",
    shortDescription: "Use slow–fast pointers to find the middle node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function findMiddleNode(head):",
      "    slow = head",
      "    fast = head",
      "    while fast != null and fast.next != null:",
      "        slow = slow.next",
      "        fast = fast.next.next",
      "    return slow",
      "end (slow is the middle node)",
    ],
    href: "/learn/linkedlist?algorithm=ll-middle-node",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linked List", "Singly", "Pointers", "Slow-Fast"],
  },
  "two-sum-sorted": {
    id: "two-sum-sorted",
    name: "Two Sum (Sorted Array)",
    category: "array",
    description:
      "Find two numbers in a sorted array that add up to a target using the two-pointer technique. One pointer starts at the beginning and the other at the end, moving inward until the pair is found.",
    shortDescription: "Two pointers to find target sum in sorted array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function twoSum(arr, target):",
      "    left = 0, right = arr.length - 1",
      "    while left < right:",
      "        sum = arr[left] + arr[right]",
      "        if sum == target:",
      "            return [arr[left], arr[right]]",
      "        else if sum < target:",
      "            left++",
      "        else:",
      "            right--",
      "    return not found",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/two-pointers?algorithm=two-sum-sorted",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "three-sum": {
    id: "three-sum",
    name: "Three Sum",
    category: "array",
    description:
      "Find three numbers in a sorted array that add up to a target using the two-pointer technique. Fix one element, then apply the two-pointer method on the remaining subarray to find a triplet.",
    shortDescription:
      "Fix one element, then use two pointers to find a triplet sum.",
    complexities: {
      best: "O(N^2)",
      average: "O(N^2)",
      worst: "O(N^2)",
      space: "O(1)",
    },
    pseudocode: [
      "function threeSum(arr, target):",
      "    for i from 0 to n-3:",
      "        left = i+1, right = n-1",
      "        while left < right:",
      "            sum = arr[i] + arr[left] + arr[right]",
      "            if sum == target:",
      "                return [arr[i], arr[left], arr[right]]",
      "            else if sum < target:",
      "                left++",
      "            else:",
      "                right--",
      "    return not found",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    href: "/learn/two-pointers?algorithm=three-sum",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "move-zeroes": {
    id: "move-zeroes",
    name: "Move Zeroes",
    category: "array",
    description:
      "Rearrange the array so that all zero elements are shifted to the end while maintaining the order of non-zero elements.",
    shortDescription: "Shift all zeroes to the end of the array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function moveZeroes(arr):",
      "    lastNonZero = 0",
      "    for i from 0 to n-1:",
      "        if arr[i] != 0:",
      "            swap arr[i], arr[lastNonZero]",
      "            lastNonZero++",
      "        else:",
      "            continue",
      "    return arr",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    href: "/learn/two-pointers?algorithm=move-zeroes",
  },
  "container-most-water": {
    id: "container-most-water",
    name: "Container With Most Water",
    category: "array",
    description:
      "Given heights, use two pointers at both ends and move the smaller height inward to maximize water area.",
    shortDescription: "Two pointers to maximize area between heights.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function mostWater(heights):",
      "    left = 0, right = n - 1, maxArea = 0",
      "    while left < right:",
      "        area = min(heights[left], heights[right])",
      "              * (right - left)",
      "        update maxArea if area is larger",
      "        if heights[left] < heights[right]:",
      "            left++",
      "        else:",
      "            right--",
      "    return maxArea",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    href: "/learn/two-pointers?algorithm=container-most-water",
    tags: ["Two Pointers", "Greedy", "Optimization"],
  },
  "trap-rain-water": {
    id: "trap-rain-water",
    name: "Trapping Rain Water",
    category: "array",
    description:
      "Compute trapped water by maintaining two pointers and keeping track of left max and right max boundaries.",
    shortDescription: "Two pointers with left/right max tracking.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function trapWater(heights):",
      "    left = 1, right = n - 2",
      "    leftMax = heights[0], rightMax = heights[n-1]",
      "    water = 0",
      "    while left <= right:",
      "        if leftMax <= rightMax:",
      "            if heights[left] >= leftMax:",
      "                leftMax = heights[left]",
      "            else:",
      "                water += leftMax - heights[left]",
      "            left++",
      "        else:",
      "            if heights[right] >= rightMax:",
      "                rightMax = heights[right]",
      "            else:",
      "                water += rightMax - heights[right]",
      "            right--",
      "    return water",
    ],
    difficulty: "advanced",
    effort: "Medium–High",
    href: "/learn/two-pointers?algorithm=trap-rain-water",
    tags: ["Two Pointers", "Greedy", "Array"],
  },
  "merge-intervals": {
    id: "merge-intervals",
    name: "Merge Intervals",
    category: "intervals",
    description:
      "Given a collection of intervals, merge all overlapping intervals into non-overlapping intervals that cover the same ranges.",
    shortDescription: "Merge overlapping intervals into consolidated ranges.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "function merge(intervals):",
      "    sort intervals by start",
      "    res = [intervals[0]]",
      "    for i from 1 to len(intervals) - 1:",
      "        cur = intervals[i]",
      "        last = res[-1]",
      "        if cur.start <= last.end:",
      "            last.end = max(last.end, cur.end)",
      "        else:",
      "            append cur to res",
      "    return res",
    ],
    difficulty: "beginner",
    effort: "low",
    href: "/learn/intervals?algorithm=merge-intervals",
    tags: ["greedy", "sorting", "intervals"],
  },
  "insert-interval": {
    id: "insert-interval",
    name: "Insert Interval",
    category: "intervals",
    description:
      "Insert a new interval into a list of non-overlapping sorted intervals, merging if necessary.",
    shortDescription:
      "Insert and merge a new interval into existing sorted intervals.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(n)",
    },
    pseudocode: [
      "function insert(intervals, new):",
      "    sort intervals by start",
      "    res = []",
      "    for iv in intervals:",
      "        if iv.end < new.start:",
      "            append iv to res",
      "        else if new.end < iv.start:",
      "            append new to res",
      "            append iv to res",
      "        else:",
      "            new.start = min(new.start, iv.start)",
      "            new.end   = max(new.end, iv.end)",
      "    append new to res",
      "    return res",
    ],
    difficulty: "intermediate",
    effort: "medium",
    href: "/learn/intervals?algorithm=insert-interval",
    tags: ["greedy", "sorting", "intervals"],
  },
  "non-overlapping-intervals": {
    id: "non-overlapping-intervals",
    name: "Non-overlapping Intervals",
    category: "intervals",
    description:
      "Find the minimum number of intervals to remove so that the rest are non-overlapping.",
    shortDescription: "Remove minimum intervals to eliminate overlaps.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(1)",
    },
    pseudocode: [
      "function nonOverlapping(intervals):",
      "    sort intervals by end",
      "    removed = 0",
      "    prev = intervals[0]",
      "    for i from 1 to len(intervals) - 1:",
      "        cur = intervals[i]",
      "        if cur.start < prev.end:",
      "            removed += 1",
      "        else:",
      "            prev = cur",
      "    return removed",
    ],
    difficulty: "intermediate",
    effort: "medium",
    href: "/learn/intervals?algorithm=non-overlapping-intervals",
    tags: ["greedy", "sorting", "intervals"],
  },
  "meeting-rooms-ii": {
    id: "meeting-rooms-ii",
    name: "Meeting Rooms II",
    category: "intervals",
    description:
      "Given meeting time intervals, find the minimum number of conference rooms required.",
    shortDescription:
      "Find minimum meeting rooms needed for overlapping intervals.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "function meetingRooms(intervals):",
      "    sort intervals by start",
      "    events = []",
      "    for iv in intervals:",
      "        add (iv.start, +1) and (iv.end, -1) to events",
      "    sort events by time (end before start if equal)",
      "    active = 0; maxrooms = 0",
      "    for e in events:",
      "        active += e.delta",
      "        if active > maxRooms:",
      "            maxRooms = active",
      "    return maxRooms",
    ],
    difficulty: "advanced",
    effort: "high",
    href: "/learn/intervals?algorithm=meeting-rooms-ii",
    tags: ["heap", "sweep-line", "intervals"],
  },
  "employee-free-time": {
    id: "employee-free-time",
    name: "Employee Free Time",
    category: "intervals",
    description:
      "Given employees' schedules (lists of working intervals), return the common free time intervals across all employees.",
    shortDescription:
      "Find gaps between merged busy intervals to get free time.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "function employeeFreeTime(schedule):",
      "    all = flatten(schedule)",
      "    sort all by start",
      "    merged = []",
      "    curr = all[0]",
      "    for i from 1 to len(all) - 1:",
      "        iv = all[i]",
      "        if iv.start <= curr.end:",
      "            curr.end = max(curr.end, iv.end)",
      "        else:",
      "            append curr to merged",
      "            free = [curr.end, iv.start]",
      "            record free as gap interval",
      "            curr = iv",
      "    append curr to merged",
      "    return merged and gaps",
    ],
    difficulty: "advanced",
    effort: "high",
    href: "/learn/intervals?algorithm=employee-free-time",
    tags: ["intervals", "merge", "scheduling"],
  },
  dfs: {
    id: "dfs",
    name: "Depth-First Search (DFS)",
    category: "graph",
    description:
      "Depth-First Search explores as far as possible along one branch before backtracking.",
    shortDescription: "Explores deep paths before backtracking.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function DFS(graph, start):",
      "   visited = set()",
      "   stack = [start]",
      "   while stack is not empty:",
      "       node = stack.pop()",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   stack.push(neighbor)",
    ],
    difficulty: "intermediate",
    effort: "medium",
    tags: ["Graph Traversal", "Stack", "Recursion"],
  },
  bfs: {
    id: "bfs",
    name: "Breadth-First Search (BFS)",
    category: "graph",
    description:
      "Breadth-First Search explores the graph level by level. It visits all neighbors before moving deeper.",
    shortDescription: "Explores graph level by level.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function BFS(graph, start):",
      "   visited = set()",
      "   queue = [start]",
      "   while queue is not empty:",
      "       node = queue.pop(0)",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   queue.append(neighbor)",
    ],
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Graph Traversal", "Queue", "Shortest Path"],
  },
};
