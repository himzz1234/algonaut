export interface AlgorithmMeta {
  id: string;
  name: string;
  category: string;
  description: string;
  shortDescription: string;
  complexities: {
    best: string;
    average: string;
    worst: string;
    space: string;
  };
  pseudocode?: string[];
  featured?: boolean;
  href?: string;
  tags?: string[];
  difficulty?: "beginner" | "intermediate" | "advanced";
  effort?: string;
}

export const algorithms: Record<string, AlgorithmMeta> = {
  "bubble-sort": {
    id: "bubble-sort",
    name: "Bubble Sort",
    category: "sorting",
    description:
      "Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It continues until the array is sorted.",
    shortDescription: "Simple sort by swapping adjacent elements.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "set n = length of array",
      "repeat until no swaps:",
      "    for i from 0 to n-2:",
      "        if arr[i] > arr[i+1]:",
      "           swap(arr[i], arr[i+1])",
      "    mark the last element as sorted",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=bubble-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Stable"],
  },
  "selection-sort": {
    id: "selection-sort",
    name: "Selection Sort",
    category: "sorting",
    description:
      "Selection Sort repeatedly selects the smallest element from the unsorted portion and swaps it with the first unsorted element, expanding the sorted portion one step at a time.",
    shortDescription: "Repeatedly selects the smallest element.",
    complexities: {
      best: "O(N²)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "set n = length of array",
      "for i from 0 to n-1:",
      "    set minIndex = i",
      "    for j from i+1 to n-1:",
      "        if arr[j] < arr[minIndex]:",
      "           minIndex = j",
      "    swap(arr[i], arr[minIndex])",
      "    mark arr[i] as sorted",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=selection-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["In-place", "Unstable"],
  },
  "insertion-sort": {
    id: "insertion-sort",
    name: "Insertion Sort",
    category: "sorting",
    description:
      "Insertion Sort builds the sorted array one element at a time by repeatedly inserting the current element into its correct position among the already-sorted elements.",
    shortDescription: "Builds sorted array one item at a time.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "set n = length of array",
      "for i from 1 to n-1:",
      "    key = arr[i]; j = i - 1",
      "    while j >= 0:",
      "       if arr[j] > key:",
      "         arr[j+1] = arr[j], j--",
      "    arr[j+1] = key",
      "mark first i+1 elements as sorted",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=insertion-sort",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Stable", "Online"],
  },
  "merge-sort": {
    id: "merge-sort",
    name: "Merge Sort",
    category: "sorting",
    description:
      "Merge Sort is a divide-and-conquer algorithm. It recursively splits the array into halves, sorts each half, and then merges the sorted halves back together.",
    shortDescription: "Splits array and merges sorted halves.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N log N)",
      space: "O(N)",
    },
    pseudocode: [
      "start with the array",
      "split the array into two halves",
      "    recursively sort the left half",
      "    recursively sort the right half",
      "merge the two sorted halves:",
      "    compare the first elements of each half",
      "        move the smaller one into the new array",
      "    repeat until one half is empty",
      "    copy any remaining elements",
      "place the merged result back into the array",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=merge-sort",
    difficulty: "intermediate",
    effort: "Medium–High",
    tags: ["Divide & Conquer", "Stable", "Recursion"],
    featured: true,
  },
  "quick-sort": {
    id: "quick-sort",
    name: "Quick Sort",
    category: "sorting",
    description:
      "Quick Sort is a divide-and-conquer algorithm. It picks a pivot and partitions the array around the pivot, recursively sorting the partitions.",
    shortDescription: "Divide-and-conquer sorting using a pivot.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N²)",
      space: "O(log N)",
    },
    pseudocode: [
      "start with the array",
      "choose the last element as the pivot",
      "    put all smaller elements to the left of the array",
      "    put all bigger elements to the right of the array",
      "place the pivot in its correct position",
      "recursively sort the left part",
      "recursively sort the right part",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=quick-sort",
    difficulty: "intermediate",
    effort: "High",
    tags: ["Divide & Conquer", "Recursion", "In-place"],
    featured: true,
  },
  "reverse-array": {
    id: "reverse-array",
    name: "Reverse Array",
    category: "array",
    description:
      "Reverse Array swaps elements from both ends moving toward the center. It uses a two-pointer approach where one pointer starts at the beginning and another at the end, swapping until they meet. This reverses the array in-place.",
    shortDescription: "Reverses an array in-place using two pointers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array",
      "point to the left element and the right element",
      "while left is before right:",
      "    swap the two elements",
      "    move left forward and right back",
      "done (array is reversed)",
    ],
    href: "/learn/array?algorithm=reverse-array",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Two Pointers", "In-place", "Array"],
  },
  "rotate-array": {
    id: "rotate-array",
    name: "Rotate Array by K steps",
    category: "array",
    description:
      "Rotate Array shifts elements in the array by a given number of steps. Each element is moved to a new position based on the rotation count, and the array is adjusted so that the order of elements wraps around. This results in the array being rotated to the left or right depending on the direction of rotation.",
    shortDescription: "Rotates an array by k steps, wrapping elements around.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array and the number of steps (k)",
      "repeat k times:",
      "    take out the first element",
      "    move every other element one place to the left",
      "    put the taken element at the end",
      "done (array is rotated)",
    ],
    href: "/learn/array?algorithm=rotate-array",
    difficulty: "beginner",
    effort: "Medium",
    featured: true,
    tags: ["Array", "Rotation", "Two Pointers"],
  },
  kadane: {
    id: "kadane",
    name: "Kadane's Algorithm",
    category: "array",
    description:
      "Kadane's Algorithm finds the maximum sum of any contiguous subarray. It keeps track of a running sum (current sum) and resets it when it becomes worse than starting fresh. The best sum found so far is updated whenever the running sum is greater.",
    shortDescription: "Finds max sum of a contiguous subarray.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array",
      "set current sum = first element",
      "set best sum = first element",
      "for each next element:",
      "    add the element to current sum",
      "    if element alone is bigger:",
      "        reset current sum to element",
      "    if current sum is bigger than best sum:",
      "        update max sum",
      "done (max sum is the answer)",
    ],
    href: "/learn/array?algorithm=kadane",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Dynamic Programming", "Subarray", "Efficient"],
    featured: true,
  },
  "prefix-sum": {
    id: "prefix-sum",
    name: "Prefix Sum Array",
    category: "array",
    description:
      "Pre-compute cumulative sums of an array to answer range sum queries efficiently.",
    shortDescription: "Precomputes cumulative sums for fast queries.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N)",
    },
    difficulty: "beginner",
    effort: "Low–Medium",
  },
  "move-zeroes": {
    id: "move-zeroes",
    name: "Move Zeroes",
    category: "array",
    description:
      "Rearrange the array so that all zero elements are shifted to the end while maintaining the order of non-zero elements.",
    shortDescription: "Shift all zeroes to the end of the array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "Initialize lastNonZero = 0",
      "For i = 0 to n - 1:",
      "    Check if arr[i] != 0",
      "    If arr[i] is non-zero:",
      "        Swap arr[i] with arr[lastNonZero]",
      "        Increment lastNonZero",
      "    Else: arr[i] is zero (do nothing)",
      "End (array has non-zero elements in front, zeros at end)",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    href: "/learn/two-pointers?algorithm=move-zeroes",
  },
  "max-sum-subarray-k": {
    id: "max-sum-subarray-k",
    name: "Max Sum Subarray of Size K",
    category: "Sliding Window",
    description:
      "Find the maximum sum of any contiguous subarray of size k. This is the simplest and most common use case of a fixed-size sliding window.",
    shortDescription: "Compute max sum of all subarrays of fixed size k.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(1)",
    },
    pseudocode: [
      "Initialize sum with sum of first k elements",
      "Set maxi = sum",
      "For i from k to n-1:",
      "    sum = sum + arr[i] - arr[i - k]",
      "    maxi = max(maxi, sum)",
      "return maxi",
    ],
    featured: true,
    href: "/learn/sliding-window?algorithm=max-sum-subarray-k",
    tags: ["array", "sliding-window", "fixed-size"],
    difficulty: "beginner",
    effort: "Easy",
  },
  "smallest-subarray-with-sum-greater-than-k": {
    id: "smallest-subarray-with-sum-greater-than-k",
    name: "Smallest Subarray with Sum ≥ K",
    category: "Sliding Window",
    description:
      "Find the length of the smallest contiguous subarray whose sum is greater than or equal to K. This introduces the shrinking window pattern.",
    shortDescription: "Find minimum window length with sum ≥ K.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(1)",
    },
    pseudocode: [
      "Initialize start = 0, sum = 0, minlen = ∞",
      "for end from 0 to n - 1:",
      "    sum += arr[end]",
      "    while sum > k:",
      "        minlen = min(minlen, end - start + 1)",
      "        currSum -= arr[start]",
      "        start++",
      "return minlen === ∞ ? 0 : minlen",
    ],
    featured: false,
    href: "/learn/sliding-window?algorithm=smallest-subarray-with-sum-greater-than-k",
    tags: ["array", "sliding-window", "variable-size"],
    difficulty: "beginner",
    effort: "Easy",
  },
  "longest-substring-without-repeat": {
    id: "longest-substring-without-repeat",
    name: "Longest Substring Without Repeating Characters",
    category: "Sliding Window",
    description:
      "Find the length of the longest substring without any repeating characters. This introduces hash maps or sets to track window content dynamically.",
    shortDescription: "Find longest substring with all unique characters.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(min(n, charset))",
    },
    pseudocode: [
      "Initialize start = 0, maxlen = 0, seen = {}",
      "for end from 0 to n - 1:",
      "    if seen contains s[end] and seen[s[end]] >= start:",
      "        start = seen[s[end]] + 1",
      "    seen[s[end]] = end",
      "    currentlen = end - start + 1",
      "    if currentlen > maxlen:",
      "        maxlen = currentlen",
      "return maxlen",
    ],
    featured: true,
    href: "/learn/sliding-window?algorithm=longest-substring-without-repeat",
    tags: ["string", "sliding-window", "hash-set"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  "linear-search": {
    id: "linear-search",
    name: "Linear Search",
    category: "searching",
    description:
      "Linear Search scans each element in the array sequentially until the target is found or the end of the array is reached.",
    shortDescription: "Scans elements sequentially for target.",
    complexities: {
      best: "O(1)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array and the target value",
      "check each element one by one:",
      "    if the element = target → found",
      "if no element matches, return 'not found'",
    ],
    href: "/learn/searching?algorithm=linear-search",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Sequential"],
  },
  "binary-search": {
    id: "binary-search",
    name: "Binary Search",
    category: "searching",
    description:
      "Binary Search repeatedly divides the search interval in half. It compares the target with the middle element and eliminates half of the array each step, until the element is found or the interval is empty.",
    shortDescription: "Halves search space to find target fast.",
    complexities: {
      best: "O(1)",
      average: "O(log N)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array and the target value",
      "set the search range between the first and last element",
      "while the range is valid:",
      "    check the middle element",
      "    if the middle = target → found",
      "    else if the middle > target:",
      "        move the search range to the left half",
      "    else if the middle < target:",
      "        move the search range to the right half",
      "if the range becomes invalid → target not found",
    ],
    href: "/learn/searching?algorithm=binary-search",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Divide & Conquer", "Efficient"],
    featured: true,
  },
  "find-min-max": {
    id: "find-min-max",
    name: "Find Min & Max",
    category: "array",
    description:
      "The Min-Max algorithm scans through the array once, keeping track of the smallest and largest elements seen so far. At each step, it compares the current element with the current min and max and updates them if necessary. This ensures both values are found in a single pass.",
    shortDescription: "Finds smallest and largest element in one scan.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array of numbers",
      "set both min and max to the first element",
      "for each element from the second to the last:",
      "    if element < min → update min",
      "    if element > max → update max",
      "end the loop",
      "min and max hold the smallest and largest values",
    ],
    href: "/learn/array?algorithm=find-min-max",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linear Scan", "Basic", "Array"],
    featured: false,
  },
  factorial: {
    id: "factorial",
    name: "Factorial (Stack View)",
    category: "recursion",
    description:
      "Factorial is defined recursively: n! = n × (n-1)! with base case 0! = 1. Recursion demonstrates the call stack as it unwinds.",
    shortDescription: "Compute factorial using recursion and stack frames.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function factorial(n):",
      "    if n == 0 or n == 1:",
      "        return 1",
      "    return n * factorial(n - 1)",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Recursion", "Stack", "Math"],
  },
  fibonacci: {
    id: "fibonacci",
    name: "Fibonacci (Recursion Tree)",
    category: "recursion",
    description:
      "Fibonacci numbers follow the recurrence F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Recursive calls expand into a tree structure, illustrating exponential growth.",
    shortDescription: "Recursive definition of Fibonacci sequence.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function fib(n):",
      "    if n == 0: return 0",
      "    if n == 1: return 1",
      "    return fib(n - 1) + fib(n - 2)",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "Tree", "Math"],
  },
  "sum-n": {
    id: "sum-n",
    name: "Sum of First N Numbers",
    category: "recursion",
    description:
      "Sum of the first N natural numbers using recursion: S(n) = n + S(n-1), with base case S(0) = 0.",
    shortDescription: "Recursive summation of first N numbers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function sumN(n):",
      "    if n == 0:",
      "        return 0",
      "    return n + sumN(n - 1)",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Recursion", "Math", "Pattern"],
  },
  "tower-of-hanoi": {
    id: "tower-of-hanoi",
    name: "Tower of Hanoi",
    category: "recursion",
    description:
      "Tower of Hanoi is a classic puzzle solved recursively: move n-1 disks to auxiliary, move the largest disk to target, then move n-1 disks from auxiliary to target.",
    shortDescription: "Recursive disk-moving puzzle solution.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function hanoi(n, source, target, auxiliary):",
      "    if n == 1:",
      "        move disk from source → target",
      "        return",
      "    hanoi(n-1, source, auxiliary, target)",
      "    move disk from source → target",
      "    hanoi(n-1, auxiliary, target, source)",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Recursion", "Puzzle", "Divide & Conquer"],
  },
  "reverse-string": {
    id: "reverse-string",
    name: "Reverse String (Recursive)",
    category: "recursion",
    description:
      "Reverse a string recursively by reducing the problem: reverse the substring after the first character, then append the first character to the result.",
    shortDescription: "Recursively reverse a string.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack + new string)",
    },
    pseudocode: [
      "function reverse(s):",
      "    if length of s <= 1:",
      "        return s",
      "    return reverse(s[1:]) + s[0]",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "String", "Divide & Conquer"],
  },
  "check-odd-even": {
    id: "check-odd-even",
    name: "Check if Number is Odd or Even",
    category: "bitmask",
    description:
      "Use bitwise AND with 1 to check if a number is odd or even. If the least significant bit is 1, the number is odd; otherwise, it is even.",
    shortDescription: "Check odd/even using least significant bit.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number",
      "check the least significant bit",
      "perform n AND mask (n & mask)",
      "if the result is 1 → the number is odd",
      "if the result is 0 → the number is even",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=check-odd-even",
    tags: ["Bits", "Odd/Even", "Trick"],
  },
  "get-ith-bit": {
    id: "get-ith-bit",
    name: "Get i-th Bit",
    category: "bitmask",
    description:
      "Check if the i-th bit of a number is set (1) or not (0) using a mask.",
    shortDescription: "Check if i-th bit is 1.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number n and a position i",
      "create a mask by shifting 1 to the left i times",
      "perform n AND mask (n & mask)",
      "if the result is not zero → the i-th bit is 1",
      "otherwise → the i-th bit is 0",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=get-ith-bit",
    tags: ["Bits", "Masking", "Check"],
  },
  "set-ith-bit": {
    id: "set-ith-bit",
    name: "Set i-th Bit",
    category: "bitmask",
    description: "Turn the i-th bit of a number to 1 using OR with a mask.",
    shortDescription: "Force i-th bit to 1.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number and a position i",
      "create a mask by shifting 1 to the left i times",
      "perform n OR mask (n | mask)",
      "this forces the i-th bit to become 1",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=set-ith-bit",
    tags: ["Bits", "Masking", "Set"],
  },
  "clear-ith-bit": {
    id: "clear-ith-bit",
    name: "Clear i-th Bit",
    category: "bitmask",
    description:
      "Turn the i-th bit of a number to 0 using AND with the inverse of a mask.",
    shortDescription: "Force i-th bit to 0.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number and a position i",
      "create a mask by shifting 1 to the left i times",
      "invert the mask so all bits are 1 except at position i",
      "perform n AND mask (n & mask)",
      "this forces the i-th bit to become 0",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=clear-ith-bit",
    tags: ["Bits", "Masking", "Clear"],
  },
  "toggle-ith-bit": {
    id: "toggle-ith-bit",
    name: "Toggle i-th Bit",
    category: "bitmask",
    description: "Flip the i-th bit of a number using XOR with a mask.",
    shortDescription: "Flip i-th bit (0→1 or 1→0).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number and a position i",
      "create a mask by shifting 1 to the left i times",
      "perform n XOR mask (n ⊕ mask)",
      "this flips the i-th bit (0 becomes 1, 1 becomes 0)",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=toggle-ith-bit",
    tags: ["Bits", "Masking", "Toggle"],
  },
  "count-set-bits": {
    id: "count-bits",
    name: "Count Set Bits",
    category: "bitmask",
    description:
      "Count the number of 1 bits in an integer using Brian Kernighan’s algorithm: repeatedly clear the lowest set bit until the number becomes zero.",
    shortDescription: "Count 1s in binary representation.",
    complexities: {
      best: "O(k), k = set bits",
      average: "O(k)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number n",
      "set count = 0",
      "while n > 0:",
      "    check the least significant bit",
      "    perform n AND mask (n & mask)",
      "    if it is 1 → increase count",
      "    shift n right by 1",
      "when n becomes 0, count holds the number of set bits",
    ],
    difficulty: "intermediate",
    href: "/learn/bitmask?algorithm=count-set-bits",
    effort: "Medium",
    tags: ["Bits", "Kernighan", "Counting"],
  },
  "power-of-two": {
    id: "power-of-two",
    name: "Check if Number is Power of Two",
    category: "bitmask",
    description:
      "A number is a power of two if it has exactly one set bit. This can be checked with n > 0 and n & (n-1) == 0.",
    shortDescription: "Check power-of-two using bit trick.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "start with a number n",
      "perform n AND n-1 (n & n-1)",
      "if the result = 0 and n > 0 → n is a power of two",
      "otherwise → n is not a power of two",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=power-of-two",
    tags: ["Bits", "Power of Two", "Trick"],
  },
  "lowest-set-bit": {
    id: "lowest-set-bit",
    name: "Get Lowest Set Bit",
    category: "bitmask",
    description:
      "Extract the lowest set bit of a number using the expression n & -n. Useful in Fenwick trees and subset generation.",
    shortDescription: "Isolate lowest set bit using n & -n.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["lowest = n & -n"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Trick", "Lowest Bit"],
  },
  "clear-lowest-set-bit": {
    id: "clear-lowest-set-bit",
    name: "Clear Lowest Set Bit",
    category: "bitmask",
    description:
      "Clear the lowest set bit of a number using n & (n-1). Commonly used for iterating through subsets efficiently.",
    shortDescription: "Clear lowest set bit using n & (n-1).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["n = n & (n - 1)"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Subset Iteration", "Trick"],
  },
  subsets: {
    id: "subsets",
    name: "Subsets (Power Set)",
    category: "Backtracking",
    description:
      "Generate all possible subsets (the power set) of a given array using recursion and backtracking.",
    shortDescription: "Generate all subsets of an array.",
    complexities: {
      best: "O(2^n)",
      average: "O(2^n)",
      worst: "O(2^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(start, path):",
      "    record path as a valid subset",
      "    for i from start to n - 1:",
      "        path.push(arr[i])",
      "        backtrack(i + 1, path)",
      "        path.pop()",
      "function generateSubsets(arr):",
      "    initialize path = []",
      "    backtrack(0, path)",
    ],
    featured: true,
    href: "/learn/backtracking?algorithm=subsets",
    tags: ["array", "backtracking", "recursion", "power-set"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  permutations: {
    id: "permutations",
    name: "Permutations",
    category: "Backtracking",
    description:
      "Generate all possible permutations of a given array using recursion and backtracking.",
    shortDescription: "Generate all permutations of an array.",
    complexities: {
      best: "O(n!)",
      average: "O(n!)",
      worst: "O(n!)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(path, used):",
      "    if path.length == n:",
      "        record path as a valid permutation",
      "        return",
      "    for i from 0 to n - 1:",
      "        if used[i] == true: continue",
      "        path.push(arr[i]); used[i] = true",
      "        backtrack(path, used)",
      "        path.pop(); used[i] = false",
      "function generatePermutations(arr):",
      "    initialize path = [], used = [false]*n",
      "    backtrack(path, used)",
    ],
    featured: true,
    href: "/learn/backtracking?algorithm=permutations",
    tags: ["array", "backtracking", "recursion", "permutations"],
    difficulty: "intermediate",
    effort: "Medium–High",
  },
  "combination-sum": {
    id: "combination-sum",
    name: "Combination Sum",
    category: "Backtracking",
    description:
      "Find all unique combinations of candidates where the chosen numbers sum to a target. Numbers can be reused multiple times.",
    shortDescription: "Generate all combinations with sum = target.",
    complexities: {
      best: "O(2^n)",
      average: "O(2^n)",
      worst: "O(2^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(start, remaining, path):",
      "    if remaining == 0:",
      "        record path as a valid combination",
      "        return",
      "    for i from start to n - 1:",
      "        if arr[i] > remaining: break",
      "        path.push(arr[i])",
      "        backtrack(i, remaining - arr[i], path)",
      "        path.pop()",
      "function combinationSum(arr, target):",
      "    sort(arr)",
      "    initialize path = []",
      "    backtrack(0, target, path)",
    ],
    featured: false,
    href: "/learn/backtracking?algorithm=combination-sum",
    tags: ["array", "backtracking", "recursion", "pruning"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  "n-queens": {
    id: "n-queens",
    name: "N-Queens",
    category: "Backtracking",
    description:
      "Place N queens on an N×N chessboard so that no two queens threaten each other. Classic constraint-satisfaction problem.",
    shortDescription: "Place N queens on the board safely.",
    complexities: {
      best: "O(N!)",
      average: "O(N!)",
      worst: "O(N!)",
      space: "O(N)",
    },
    pseudocode: [
      "result = []",
      "function backtrack(row, columns, diag1, diag2, board):",
      "    if row == N:",
      "        result.push(board.copy())",
      "        return",
      "    for col from 0 to N - 1:",
      "        if col in columns or row+col in diag1 or row-col in diag2: continue",
      "        placeQueen(row, col)",
      "        backtrack(row + 1, columns ∪ col, diag1 ∪ (row+col), diag2 ∪ (row-col), board)",
      "        removeQueen(row, col)",
      "backtrack(0, {}, {}, {}, emptyBoard)",
      "return result",
    ],
    featured: true,
    tags: ["matrix", "backtracking", "recursion", "constraints"],
    difficulty: "intermediate",
    effort: "High",
  },
  "word-search": {
    id: "word-search",
    name: "Word Search",
    category: "Backtracking",
    description:
      "Search for a word in a 2D grid by moving horizontally or vertically. Each letter cell can only be used once per word.",
    shortDescription: "Find if a word exists in a grid.",
    complexities: {
      best: "O(N*M*L)",
      average: "O(N*M*L)",
      worst: "O(N*M*4^L)",
      space: "O(L)",
    },
    pseudocode: [
      "function dfs(r, c, index):",
      "    if index == len(word): return true",
      "    if out of bounds or board[r][c] != word[index]: return false",
      "    mark board[r][c] as visited",
      "    for each direction in [up, down, left, right]:",
      "        if dfs(r+dr, c+dc, index+1): return true",
      "    unmark board[r][c]",
      "    return false",
      "for each cell in board:",
      "    if dfs(r, c, 0): return true",
      "return false",
    ],
    featured: false,
    tags: ["matrix", "backtracking", "dfs"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  "sudoku-solver": {
    id: "sudoku-solver",
    name: "Sudoku Solver",
    category: "Backtracking",
    description:
      "Fill a 9×9 Sudoku board so that every row, column, and 3×3 sub-box contains digits 1 to 9 without repetition.",
    shortDescription: "Solve Sudoku using backtracking.",
    complexities: {
      best: "O(1)",
      average: "O(9^m)",
      worst: "O(9^m)",
      space: "O(m)",
    },
    pseudocode: [
      "function solve():",
      "    for each cell (r, c):",
      "        if board[r][c] is empty:",
      "            for d from 1 to 9:",
      "                if d is valid in row, col, box:",
      "                    place d",
      "                    if solve(): return true",
      "                    remove d",
      "            return false",
      "    return true",
      "solve()",
    ],
    featured: false,
    tags: ["matrix", "backtracking", "constraint-satisfaction"],
    difficulty: "advanced",
    effort: "Very High",
  },
  "letter-combinations-phone": {
    id: "letter-combinations-phone",
    name: "Letter Combinations of a Phone Number",
    category: "Backtracking",
    description:
      "Given a string of digits from 2-9, return all possible letter combinations based on phone keypad mappings.",
    shortDescription: "Generate letter combinations for phone digits.",
    complexities: {
      best: "O(4^n)",
      average: "O(4^n)",
      worst: "O(4^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(index, path):",
      "    if index == digits.length:",
      "        record path as a valid combination",
      "        return",
      "    digit = digits[index]",
      "    for each letter in mapping[digit]:",
      "        path.push(letter)",
      "        backtrack(index + 1, path)",
      "        path.pop()",
      "function letterCombinations(digits):",
      "    initialize path = []",
      "    backtrack(0, path)",
    ],
    featured: false,
    href: "/learn/backtracking?algorithm=letter-combinations-phone",
    tags: ["string", "backtracking", "recursion"],
    difficulty: "beginner",
    effort: "Easy–Medium",
  },
  "ll-insert-end": {
    id: "ll-insert-end",
    name: "Insert at End (Singly List)",
    category: "linkedlist",
    description:
      "Given only the head pointer, traverse to the tail and attach a new node there. This runs in O(N).",
    shortDescription: "Traverse to tail and link new node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with head",
      "if head is null:",
      "    create new node → head",
      "    return head",
      "set curr = head",
      "while curr.next is not null:",
      "    move curr forward",
      "create new node",
      "link curr.next to new node",
      "return head",
    ],
    href: "/learn/list?algorithm=ll-insert-end",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Linked List", "Singly", "Pointers", "Insertion"],
  },
  "ll-reverse": {
    id: "ll-reverse",
    name: "Reverse a Linked List (Singly)",
    category: "linkedlist",
    description:
      "Reverse the order of nodes in a singly linked list by re-wiring each node’s next pointer.",
    shortDescription: "Reverse a singly linked list in-place.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the head node",
      "set prev = null",
      "set curr = head",
      "while curr is not null:",
      "    save next node",
      "    point curr to prev",
      "    move prev to curr",
      "    move curr to next",
      "end loop → prev is new head",
      "return prev",
    ],
    href: "/learn/list?algorithm=ll-reverse",
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Reversal"],
  },
  "ll-cycle-detect-floyd": {
    id: "ll-cycle-detect-floyd",
    name: "Cycle Detection (Floyd's Algorithm)",
    category: "linkedlist",
    description:
      "Detect whether a cycle exists in a singly linked list using Floyd’s cycle-finding algorithm (tortoise and hare).",
    shortDescription: "Use two pointers (slow/fast) to detect a cycle.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the head node",
      "set slow = head",
      "set fast = head",
      "while fast and fast.next are not null:",
      "    move slow one step",
      "    move fast two steps",
      "    if slow == fast -> cycle detected",
      "        return true",
      "end loop",
      "return false",
    ],
    href: "/learn/list?algorithm=ll-cycle-detect-floyd",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Cycle Detection", "Floyd"],
    featured: true,
  },
  "ll-merge-two-sorted": {
    id: "ll-merge-two-sorted",
    name: "Merge Two Sorted Lists (Singly)",
    category: "linkedlist",
    description:
      "Given two singly linked lists sorted in ascending order, merge them into a single sorted list by rearranging pointers in-place.",
    shortDescription: "Merge two sorted linked lists in-place.",
    complexities: {
      best: "O(N + M)",
      average: "O(N + M)",
      worst: "O(N + M)",
      space: "O(1)",
    },
    pseudocode: [
      "start with head nodes of list A and list B",
      "set curr1 = head1, curr2 = head2",
      "set prev1 = null",
      "while curr1 and curr2:",
      "   if curr1.value <= curr2.value:",
      "     move prev1 to curr1",
      "     move curr1 forward",
      "   else:",
      "     if prev1 is not null:",
      "       link prev1.next to curr2",
      "     else:",
      "       update head1 to curr2",
      "     save next2 = curr2.next",
      "     link curr2.next to curr1",
      "     move prev1 to curr2",
      "     move curr2 to next2",
      "if curr2 still has nodes:",
      "   link prev1.next to curr2",
      "return head1",
    ],
    href: "/learn/list?algorithm=ll-merge-two-sorted",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Merge", "Two Pointers"],
  },
  "ll-middle-node": {
    id: "ll-middle-node",
    name: "Find Middle Node (Singly)",
    category: "linkedlist",
    description:
      "Find the middle node of a singly linked list using the slow–fast pointer technique.",
    shortDescription: "Use slow–fast pointers to find the middle node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with head node",
      "set slow = head",
      "set fast = head",
      "while fast and fast.next is not null:",
      "    move slow one step",
      "    move fast two steps",
      "end loop",
      "return slow",
    ],
    href: "/learn/list?algorithm=ll-middle-node",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linked List", "Singly", "Pointers", "Slow-Fast"],
  },
  "two-sum-sorted": {
    id: "two-sum-sorted",
    name: "Two Sum (Sorted Array)",
    category: "array",
    description:
      "Find two numbers in a sorted array that add up to a target using the two-pointer technique. One pointer starts at the beginning and the other at the end, moving inward until the pair is found.",
    shortDescription: "Two pointers to find target sum in sorted array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with sorted array (left = 0, right = n-1)",
      "while left < right:",
      "    sum = arr[left] + arr[right]",
      "    if sum == target:",
      "        return indices (found)",
      "    else if sum < target:",
      "        move left++",
      "    else:",
      "        move right--",
      "if no pair found → return none",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/two-pointers?algorithm=two-sum-sorted",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "three-sum": {
    id: "three-sum",
    name: "Three Sum",
    category: "array",
    description:
      "Find three numbers in a sorted array that add up to a target using the two-pointer technique. Fix one element, then apply the two-pointer method on the remaining subarray to find a triplet.",
    shortDescription:
      "Fix one element, then use two pointers to find a triplet sum.",
    complexities: {
      best: "O(N^2)",
      average: "O(N^2)",
      worst: "O(N^2)",
      space: "O(1)",
    },
    pseudocode: [
      "start with sorted array",
      "for i from 0 to n-3:",
      "    set left = i+1, right = n-1",
      "    while left < right:",
      "        sum = arr[i] + arr[left] + arr[right]",
      "        if sum == target → return triplet",
      "        else if sum < target:",
      "            move left++",
      "        else:",
      "            move right--",
      "if no triplet found → return none",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    href: "/learn/two-pointers?algorithm=three-sum",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "container-most-water": {
    id: "container-most-water",
    name: "Container With Most Water",
    category: "array",
    description:
      "Given heights, use two pointers at both ends and move the smaller height inward to maximize water area.",
    shortDescription: "Two pointers to maximize area between heights.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with an array of heights",
      "while left < right:",
      "    area = min(height[left], height[right]) × (right - left)",
      "    update max area if needed",
      "    if height[left] < height[right]:",
      "        move left++",
      "    else:",
      "        move right--",
      "return the maximum area found",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    href: "/learn/two-pointers?algorithm=container-most-water",
    tags: ["Two Pointers", "Greedy", "Optimization"],
  },
  "trap-rain-water": {
    id: "trap-rain-water",
    name: "Trapping Rain Water",
    category: "array",
    description:
      "Compute trapped water by maintaining two pointers and keeping track of left max and right max boundaries.",
    shortDescription: "Two pointers with left/right max tracking.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with an array of heights",
      "while left <= right:",
      "    if leftMax <= rightMax:",
      "        if arr[left] >= leftMax → update leftMax",
      "        else → add (leftMax - arr[left]) to water and move left++",
      "    else:",
      "        if arr[right] >= rightMax → update rightMax",
      "        else → add (rightMax - arr[right]) to water and move right--",
      "return total trapped water",
    ],
    difficulty: "advanced",
    effort: "Medium–High",
    href: "/learn/two-pointers?algorithm=trap-rain-water",
    tags: ["Two Pointers", "Greedy", "Array"],
  },
  "merge-intervals": {
    id: "merge-intervals",
    name: "Merge Intervals",
    category: "Intervals",
    description:
      "Given a collection of intervals, merge all overlapping intervals into non-overlapping intervals that cover the same ranges.",
    shortDescription: "Merge overlapping intervals into consolidated ranges.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n) for output",
    },
    pseudocode: [
      "sort intervals by start time",
      "initialize merged list",
      "for each interval:",
      "    if merged is empty or current.start > last.end:",
      "        append interval to merged",
      "    else:",
      "        merge with last interval (update last.end)",
      "return merged",
    ],
    difficulty: "beginner",
    effort: "low",
    href: "/learn/intervals?algorithm=merge-intervals",
    tags: ["greedy", "sorting", "intervals"],
  },
  "insert-interval": {
    id: "insert-interval",
    name: "Insert Interval",
    category: "Intervals",
    description:
      "Insert a new interval into a list of non-overlapping sorted intervals, merging if necessary.",
    shortDescription:
      "Insert and merge a new interval into existing sorted intervals.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(n) for output",
    },
    pseudocode: [
      "sort intervals by start time",
      "initialize merged list",
      "for interval in intervals:",
      "    if interval.end < new.start:",
      "        add interval to result",
      "    else if interval.start > new.end:",
      "        add new interval, then remaining intervals",
      "    else:",
      "        merge interval with new (update start/end)",
      "add new interval",
      "return merged",
    ],
    difficulty: "intermediate",
    effort: "medium",
    href: "/learn/intervals?algorithm=insert-interval",
    tags: ["greedy", "sorting", "intervals"],
  },
  "non-overlapping-intervals": {
    id: "non-overlapping-intervals",
    name: "Non-overlapping Intervals",
    category: "Intervals",
    description:
      "Find the minimum number of intervals to remove so that the rest are non-overlapping.",
    shortDescription: "Remove minimum intervals to eliminate overlaps.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(1)",
    },
    pseudocode: [
      "sort intervals by end time",
      "end = -∞",
      "for interval in intervals:",
      "    if interval.start >= end:",
      "        end = interval.end",
      "    else:",
      "        remove interval",
      "return original",
    ],
    difficulty: "intermediate",
    effort: "medium",
    href: "/learn/intervals?algorithm=non-overlapping-intervals",
    tags: ["greedy", "sorting", "intervals"],
  },
  "meeting-rooms-ii": {
    id: "meeting-rooms-ii",
    name: "Meeting Rooms II",
    category: "Intervals",
    description:
      "Given meeting time intervals, find the minimum number of conference rooms required.",
    shortDescription:
      "Find minimum meeting rooms needed for overlapping intervals.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "sort start times and end times",
      "rooms = 0, endPtr = 0",
      "for each start time:",
      "    if start < end[endPtr]:",
      "        rooms++",
      "    else:",
      "        endPtr++",
      "return rooms",
    ],
    difficulty: "advanced",
    effort: "high",
    href: "/learn/intervals?algorithm=meeting-rooms-ii",
    tags: ["heap", "sweep-line", "intervals"],
  },
  "employee-free-time": {
    id: "employee-free-time",
    name: "Employee Free Time",
    category: "Intervals",
    description:
      "Given employees' schedules (lists of working intervals), return the common free time intervals across all employees.",
    shortDescription:
      "Find gaps between merged busy intervals to get free time.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "collect all intervals from all employees",
      "sort intervals by start time",
      "curr = first interval",
      "for each interval in intervals[1:]:",
      "    if interval.start <= curr.end:",
      "        curr.end = max(curr.end, interval.end)",
      "    else:",
      "        add curr to merged",
      "        record free time [curr.end, interval.start]",
      "        curr = interval",
      "add curr to merged",
      "return merged and free times",
    ],
    difficulty: "advanced",
    effort: "high",
    href: "/learn/intervals?algorithm=employee-free-time",
    tags: ["intervals", "merge", "scheduling"],
  },
  dfs: {
    id: "dfs",
    name: "Depth-First Search (DFS)",
    category: "graph",
    description:
      "Depth-First Search explores as far as possible along one branch before backtracking.",
    shortDescription: "Explores deep paths before backtracking.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function DFS(graph, start):",
      "   visited = set()",
      "   stack = [start]",
      "   while stack is not empty:",
      "       node = stack.pop()",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   stack.push(neighbor)",
    ],
    difficulty: "intermediate",
    effort: "medium",
    tags: ["Graph Traversal", "Stack", "Recursion"],
  },
  bfs: {
    id: "bfs",
    name: "Breadth-First Search (BFS)",
    category: "graph",
    description:
      "Breadth-First Search explores the graph level by level. It visits all neighbors before moving deeper.",
    shortDescription: "Explores graph level by level.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function BFS(graph, start):",
      "   visited = set()",
      "   queue = [start]",
      "   while queue is not empty:",
      "       node = queue.pop(0)",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   queue.append(neighbor)",
    ],
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Graph Traversal", "Queue", "Shortest Path"],
  },
};
