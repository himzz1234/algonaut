export interface AlgorithmMeta {
  id: string;
  name: string;
  category: string;
  description: string;
  shortDescription: string;
  complexities: {
    best: string;
    average: string;
    worst: string;
    space: string;
  };
  pseudocode?: string[];
  featured?: boolean;
  href?: string;
  tags?: string[];
  difficulty?: "beginner" | "intermediate" | "advanced";
  effort?: string;
}

export const algorithms: Record<string, AlgorithmMeta> = {
  "bubble-sort": {
    id: "bubble-sort",
    name: "Bubble Sort",
    category: "sorting",
    description:
      "Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It continues until the array is sorted.",
    shortDescription: "Simple sort by swapping adjacent elements.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the full array",
      "repeat until array is sorted:",
      "    compare each pair of neighbors",
      "    if left > right, swap them",
      "    mark the last element as sorted",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=bubble-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Stable"],
  },
  "selection-sort": {
    id: "selection-sort",
    name: "Selection Sort",
    category: "sorting",
    description:
      "Selection Sort repeatedly selects the smallest element from the unsorted portion and swaps it with the first unsorted element, expanding the sorted portion one step at a time.",
    shortDescription: "Repeatedly selects the smallest element.",
    complexities: {
      best: "O(N²)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array",
      "for each position from start to end:",
      "    assume the first unsorted element is the smallest",
      "    compare it with the rest of the unsorted elements",
      "        if a smaller element is found, mark it as the new smallest",
      "    swap the smallest element with the first unsorted element",
      "    mark this element as sorted",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=selection-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["In-place", "Unstable"],
  },
  "insertion-sort": {
    id: "insertion-sort",
    name: "Insertion Sort",
    category: "sorting",
    description:
      "Insertion Sort builds the sorted array one element at a time by repeatedly inserting the current element into its correct position among the already-sorted elements.",
    shortDescription: "Builds sorted array one item at a time.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array",
      "for each element from the second one:",
      "    pick it as the 'key'",
      "    compare the key with previous elements",
      "        if key is smaller, shift the bigger one right",
      "    put the key in the correct spot",
      "mark elements up to here as sorted",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=insertion-sort",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Stable", "Online"],
  },
  "merge-sort": {
    id: "merge-sort",
    name: "Merge Sort",
    category: "sorting",
    description:
      "Merge Sort is a divide-and-conquer algorithm. It recursively splits the array into halves, sorts each half, and then merges the sorted halves back together.",
    shortDescription: "Splits array and merges sorted halves.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N log N)",
      space: "O(N)",
    },
    pseudocode: [
      "start with the array",
      "split the array into two halves",
      "    recursively sort the left half",
      "    recursively sort the right half",
      "merge the two sorted halves:",
      "    compare the first elements of each half",
      "        move the smaller one into the new array",
      "    repeat until one half is empty",
      "    copy any remaining elements",
      "place the merged result back into the array",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=merge-sort",
    difficulty: "intermediate",
    effort: "Medium–High",
    tags: ["Divide & Conquer", "Stable", "Recursion"],
    featured: true,
  },
  "quick-sort": {
    id: "quick-sort",
    name: "Quick Sort",
    category: "sorting",
    description:
      "Quick Sort is a divide-and-conquer algorithm. It picks a pivot and partitions the array around the pivot, recursively sorting the partitions.",
    shortDescription: "Divide-and-conquer sorting using a pivot.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N²)",
      space: "O(log N)",
    },
    pseudocode: [
      "start with the array",
      "choose the last element as the pivot",
      "    put all smaller elements to the left of the pivot",
      "    put all bigger elements to the right of the pivot",
      "place the pivot in its correct position",
      "recursively sort the left part",
      "recursively sort the right part",
      "done (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=quick-sort",
    difficulty: "intermediate",
    effort: "High",
    tags: ["Divide & Conquer", "Recursion", "In-place"],
    featured: true,
  },
  "reverse-array": {
    id: "reverse-array",
    name: "Reverse Array",
    category: "array",
    description:
      "Reverse Array swaps elements from both ends moving toward the center. It uses a two-pointer approach where one pointer starts at the beginning and another at the end, swapping until they meet. This reverses the array in-place.",
    shortDescription: "Reverses an array in-place using two pointers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array",
      "point to the left element and the right element",
      "while left is before right:",
      "    swap the two elements",
      "    move left forward and right back",
      "done (array is reversed)",
    ],
    href: "/learn/array?algorithm=reverse-array",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Two Pointers", "In-place", "Array"],
  },
  "rotate-array": {
    id: "rotate-array",
    name: "Rotate Array by K steps",
    category: "array",
    description:
      "Rotate Array shifts elements in the array by a given number of steps. Each element is moved to a new position based on the rotation count, and the array is adjusted so that the order of elements wraps around. This results in the array being rotated to the left or right depending on the direction of rotation.",
    shortDescription: "Rotates an array by k steps, wrapping elements around.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array and the number of steps (k)",
      "repeat k times:",
      "    take out the first element",
      "    move every other element one place to the left",
      "    put the taken element at the end",
      "done (array is rotated)",
    ],
    href: "/learn/array?algorithm=rotate-array",
    difficulty: "beginner",
    effort: "Medium",
    featured: true,
    tags: ["Array", "Rotation", "Two Pointers"],
  },
  kadane: {
    id: "kadane",
    name: "Kadane's Algorithm",
    category: "array",
    description:
      "Kadane's Algorithm finds the maximum sum of any contiguous subarray. It keeps track of a running sum (current sum) and resets it when it becomes worse than starting fresh. The best sum found so far is updated whenever the running sum is greater.",
    shortDescription: "Finds max sum of a contiguous subarray.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array",
      "set current sum = first element",
      "set best sum = first element",
      "for each next element:",
      "    add the element to current sum",
      "    if element alone is bigger:",
      "        reset current sum to element",
      "    if current sum is bigger than best sum:",
      "        update max sum",
      "done (max sum is the answer)",
    ],
    href: "/learn/array?algorithm=kadane",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Dynamic Programming", "Subarray", "Efficient"],
    featured: true,
  },
  "prefix-sum": {
    id: "prefix-sum",
    name: "Prefix Sum Array",
    category: "array",
    description:
      "Pre-compute cumulative sums of an array to answer range sum queries efficiently.",
    shortDescription: "Precomputes cumulative sums for fast queries.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N)",
    },
    difficulty: "beginner",
    effort: "Low–Medium",
  },
  "move-zeroes": {
    id: "move-zeroes",
    name: "Move Zeroes",
    category: "array",
    description:
      "Rearrange the array so that all zero elements are shifted to the end while maintaining the order of non-zero elements.",
    shortDescription: "Shift all zeroes to the end of the array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    difficulty: "beginner",
    effort: "Low–Medium",
  },
  "linear-search": {
    id: "linear-search",
    name: "Linear Search",
    category: "searching",
    description:
      "Linear Search scans each element in the array sequentially until the target is found or the end of the array is reached.",
    shortDescription: "Scans elements sequentially for target.",
    complexities: {
      best: "O(1)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array and the target value",
      "check each element one by one:",
      "    if the element = target → found",
      "if no element matches, return 'not found'",
    ],
    href: "/learn/searching?algorithm=linear-search",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Sequential"],
  },
  "binary-search": {
    id: "binary-search",
    name: "Binary Search",
    category: "searching",
    description:
      "Binary Search repeatedly divides the search interval in half. It compares the target with the middle element and eliminates half of the array each step, until the element is found or the interval is empty.",
    shortDescription: "Halves search space to find target fast.",
    complexities: {
      best: "O(1)",
      average: "O(log N)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array and the target value",
      "set the search range between the first and last element",
      "while the range is valid:",
      "    check the middle element",
      "    if the middle = target → found",
      "    else if the middle > target:",
      "        move the search range to the left half",
      "    else if the middle < target:",
      "        move the search range to the right half",
      "if the range becomes invalid → target not found",
    ],
    href: "/learn/searching?algorithm=binary-search",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Divide & Conquer", "Efficient"],
    featured: true,
  },
  "find-min-max": {
    id: "find-min-max",
    name: "Find Min & Max",
    category: "array",
    description:
      "The Min-Max algorithm scans through the array once, keeping track of the smallest and largest elements seen so far. At each step, it compares the current element with the current min and max and updates them if necessary. This ensures both values are found in a single pass.",
    shortDescription: "Finds smallest and largest element in one scan.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the array of numbers",
      "set both min and max to the first element",
      "for each element from the second to the last:",
      "    if element < min → update min",
      "    if element > max → update max",
      "end the loop",
      "min and max hold the smallest and largest values",
    ],
    href: "/learn/array?algorithm=find-min-max",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linear Scan", "Basic", "Array"],
    featured: false,
  },
  factorial: {
    id: "factorial",
    name: "Factorial (Stack View)",
    category: "recursion",
    description:
      "Factorial is defined recursively: n! = n × (n-1)! with base case 0! = 1. Recursion demonstrates the call stack as it unwinds.",
    shortDescription: "Compute factorial using recursion and stack frames.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function factorial(n):",
      "    if n == 0 or n == 1:",
      "        return 1",
      "    return n * factorial(n - 1)",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Recursion", "Stack", "Math"],
  },

  fibonacci: {
    id: "fibonacci",
    name: "Fibonacci (Recursion Tree)",
    category: "recursion",
    description:
      "Fibonacci numbers follow the recurrence F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Recursive calls expand into a tree structure, illustrating exponential growth.",
    shortDescription: "Recursive definition of Fibonacci sequence.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function fib(n):",
      "    if n == 0: return 0",
      "    if n == 1: return 1",
      "    return fib(n - 1) + fib(n - 2)",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "Tree", "Math"],
  },
  "sum-n": {
    id: "sum-n",
    name: "Sum of First N Numbers",
    category: "recursion",
    description:
      "Sum of the first N natural numbers using recursion: S(n) = n + S(n-1), with base case S(0) = 0.",
    shortDescription: "Recursive summation of first N numbers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function sumN(n):",
      "    if n == 0:",
      "        return 0",
      "    return n + sumN(n - 1)",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Recursion", "Math", "Pattern"],
  },
  "tower-of-hanoi": {
    id: "tower-of-hanoi",
    name: "Tower of Hanoi",
    category: "recursion",
    description:
      "Tower of Hanoi is a classic puzzle solved recursively: move n-1 disks to auxiliary, move the largest disk to target, then move n-1 disks from auxiliary to target.",
    shortDescription: "Recursive disk-moving puzzle solution.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function hanoi(n, source, target, auxiliary):",
      "    if n == 1:",
      "        move disk from source → target",
      "        return",
      "    hanoi(n-1, source, auxiliary, target)",
      "    move disk from source → target",
      "    hanoi(n-1, auxiliary, target, source)",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Recursion", "Puzzle", "Divide & Conquer"],
  },
  "reverse-string": {
    id: "reverse-string",
    name: "Reverse String (Recursive)",
    category: "recursion",
    description:
      "Reverse a string recursively by reducing the problem: reverse the substring after the first character, then append the first character to the result.",
    shortDescription: "Recursively reverse a string.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack + new string)",
    },
    pseudocode: [
      "function reverse(s):",
      "    if length of s <= 1:",
      "        return s",
      "    return reverse(s[1:]) + s[0]",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "String", "Divide & Conquer"],
  },
  "check-odd-even": {
    id: "check-odd-even",
    name: "Check if Number is Odd or Even",
    category: "recursion",
    description:
      "Use bitwise AND with 1 to check if a number is odd or even. If the least significant bit is 1, the number is odd; otherwise, it is even.",
    shortDescription: "Check odd/even using least significant bit.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function isOdd(n):",
      "    if (n & 1) == 1: return true",
      "    else return false",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Odd/Even", "Trick"],
  },

  "ith-bit": {
    id: "ith-bit",
    name: "Get / Set / Toggle ith Bit",
    category: "recursion",
    description:
      "Bitwise tricks to get, set, and toggle the ith bit of an integer using shift and bitwise operators.",
    shortDescription: "Manipulate specific bits using masks.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "mask = 1 << i",
      "get: (n & mask) != 0",
      "set: n | mask",
      "clear: n & ~mask",
      "toggle: n ^ mask",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Bits", "Masking", "Operations"],
  },

  "count-bits": {
    id: "count-bits",
    name: "Count Set Bits",
    category: "recursion",
    description:
      "Count the number of 1 bits in an integer using Brian Kernighan’s algorithm: repeatedly clear the lowest set bit until the number becomes zero.",
    shortDescription: "Count 1s in binary representation.",
    complexities: {
      best: "O(k) where k = set bits",
      average: "O(k)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "function countBits(n):",
      "    count = 0",
      "    while n > 0:",
      "        n = n & (n - 1)",
      "        count++",
      "    return count",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Bits", "Kernighan", "Counting"],
  },

  "single-number": {
    id: "single-number",
    name: "Find the Single Number",
    category: "recursion",
    description:
      "Given an array where every element appears twice except for one, find the single number using XOR. XOR of duplicates cancels out, leaving the unique element.",
    shortDescription: "Find non-duplicate element using XOR.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function singleNumber(arr):",
      "    result = 0",
      "    for each num in arr:",
      "        result = result ^ num",
      "    return result",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Bits", "XOR", "Array"],
  },
  "power-of-two": {
    id: "power-of-two",
    name: "Check if Number is Power of Two",
    category: "recursion",
    description:
      "A number is a power of two if it has exactly one set bit. This can be checked with n > 0 and n & (n-1) == 0.",
    shortDescription: "Check power-of-two using bit trick.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function isPowerOfTwo(n):",
      "    return n > 0 and (n & (n - 1)) == 0",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Power of Two", "Trick"],
  },

  "swap-using-xor": {
    id: "swap-using-xor",
    name: "Swap Two Numbers Using XOR",
    category: "recursion",
    description:
      "Swap two variables without using a temporary variable by leveraging XOR properties.",
    shortDescription: "XOR-swap trick for two numbers.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["a = a ^ b", "b = a ^ b", "a = a ^ b"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Swap", "XOR"],
  },
  "lowest-set-bit": {
    id: "lowest-set-bit",
    name: "Get Lowest Set Bit",
    category: "recursion",
    description:
      "Extract the lowest set bit of a number using the expression n & -n. Useful in Fenwick trees and subset generation.",
    shortDescription: "Isolate lowest set bit using n & -n.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["lowest = n & -n"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Trick", "Lowest Bit"],
  },
  "clear-lowest-set-bit": {
    id: "clear-lowest-set-bit",
    name: "Clear Lowest Set Bit",
    category: "recursion",
    description:
      "Clear the lowest set bit of a number using n & (n-1). Commonly used for iterating through subsets efficiently.",
    shortDescription: "Clear lowest set bit using n & (n-1).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["n = n & (n - 1)"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Subset Iteration", "Trick"],
  },
  "ll-insert-end": {
    id: "ll-insert-end",
    name: "Insert at End (Singly List)",
    category: "linkedlist",
    description:
      "Given only the head pointer, traverse to the tail and attach a new node there. This runs in O(N).",
    shortDescription: "Traverse to tail and link new node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with head",
      "if head is null:",
      "    create new node → head",
      "    return head",
      "set curr = head",
      "while curr.next is not null:",
      "    move curr forward",
      "create new node",
      "link curr.next to new node",
      "return head",
    ],
    href: "/learn/list?algorithm=ll-insert-end",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Linked List", "Singly", "Pointers", "Insertion"],
  },
  "ll-reverse": {
    id: "ll-reverse",
    name: "Reverse a Linked List (Singly)",
    category: "linkedlist",
    description:
      "Reverse the order of nodes in a singly linked list by re-wiring each node’s next pointer.",
    shortDescription: "Reverse a singly linked list in-place.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the head node",
      "set prev = null",
      "set curr = head",
      "while curr is not null:",
      "    save next node",
      "    point curr to prev",
      "    move prev to curr",
      "    move curr to next",
      "end loop → prev is new head",
      "return prev",
    ],
    href: "/learn/list?algorithm=ll-reverse",
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Reversal"],
  },
  "ll-cycle-detect-floyd": {
    id: "ll-cycle-detect-floyd",
    name: "Cycle Detection (Floyd's Algorithm)",
    category: "linkedlist",
    description:
      "Detect whether a cycle exists in a singly linked list using Floyd’s cycle-finding algorithm (tortoise and hare).",
    shortDescription: "Use two pointers (slow/fast) to detect a cycle.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with the head node",
      "set slow = head",
      "set fast = head",
      "while fast and fast.next are not null:",
      "    move slow one step",
      "    move fast two steps",
      "    if slow == fast -> cycle detected",
      "        return true",
      "end loop",
      "return false",
    ],
    href: "/learn/list?algorithm=ll-cycle-detect-floyd",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Cycle Detection", "Floyd"],
    featured: true,
  },
  "ll-merge-two-sorted": {
    id: "ll-merge-two-sorted",
    name: "Merge Two Sorted Lists (Singly)",
    category: "linkedlist",
    description:
      "Given two singly linked lists sorted in ascending order, merge them into a single sorted list by rearranging pointers in-place.",
    shortDescription: "Merge two sorted linked lists in-place.",
    complexities: {
      best: "O(N + M)",
      average: "O(N + M)",
      worst: "O(N + M)",
      space: "O(1)",
    },
    pseudocode: [
      "start with head nodes of list A and list B",
      "set curr1 = head1, curr2 = head2",
      "set prev1 = null",
      "while curr1 and curr2:",
      "   if curr1.value <= curr2.value:",
      "     move prev1 to curr1",
      "     move curr1 forward",
      "   else:",
      "     if prev1 is not null:",
      "       link prev1.next to curr2",
      "     else:",
      "       update head1 to curr2",
      "     save next2 = curr2.next",
      "     link curr2.next to curr1",
      "     move prev1 to curr2",
      "     move curr2 to next2",
      "if curr2 still has nodes:",
      "   link prev1.next to curr2",
      "return head1",
    ],
    href: "/learn/list?algorithm=ll-merge-two-sorted",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Merge", "Two Pointers"],
  },
  "ll-middle-node": {
    id: "ll-middle-node",
    name: "Find Middle Node (Singly)",
    category: "linkedlist",
    description:
      "Find the middle node of a singly linked list using the slow–fast pointer technique.",
    shortDescription: "Use slow–fast pointers to find the middle node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "start with head node",
      "set slow = head",
      "set fast = head",
      "while fast and fast.next is not null:",
      "    move slow one step",
      "    move fast two steps",
      "end loop",
      "return slow",
    ],
    href: "/learn/list?algorithm=ll-middle-node",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linked List", "Singly", "Pointers", "Slow-Fast"],
  },
  "two-sum-sorted": {
    id: "two-sum-sorted",
    name: "Two Sum (Sorted Array)",
    category: "array",
    description:
      "Find two numbers in a sorted array that add up to a target using the two-pointer technique. One pointer starts at the beginning and the other at the end, moving inward until the pair is found.",
    shortDescription: "Two pointers to find target sum in sorted array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "set left = 0, right = n-1",
      "while left < right:",
      "    sum = arr[left] + arr[right]",
      "    if sum == target → return indices",
      "    else if sum < target → move left++",
      "    else → move right--",
      "if no pair found → return none",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "remove-duplicates-sorted": {
    id: "remove-duplicates-sorted",
    name: "Remove Duplicates from Sorted Array",
    category: "array",
    description:
      "Remove duplicates in-place from a sorted array by using two pointers: one for placing unique values, the other for scanning the array.",
    shortDescription: "Two pointers to compact sorted array in-place.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "set write = 1",
      "for read from 1 to n-1:",
      "    if arr[read] != arr[read-1]:",
      "        arr[write] = arr[read]",
      "        write++",
      "return write (new length)",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Two Pointers", "In-place", "Array"],
  },
  "container-most-water": {
    id: "container-most-water",
    name: "Container With Most Water",
    category: "array",
    description:
      "Given heights, use two pointers at both ends and move the smaller height inward to maximize water area.",
    shortDescription: "Two pointers to maximize area between heights.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "set left = 0, right = n-1",
      "maxArea = 0",
      "while left < right:",
      "    area = (right-left) * min(height[left], height[right])",
      "    maxArea = max(maxArea, area)",
      "    if height[left] < height[right]: left++ else right--",
      "return maxArea",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Two Pointers", "Greedy", "Optimization"],
  },
  "trap-rain-water": {
    id: "trap-rain-water",
    name: "Trapping Rain Water",
    category: "array",
    description:
      "Compute trapped water by maintaining two pointers and keeping track of left max and right max boundaries.",
    shortDescription: "Two pointers with left/right max tracking.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "set left = 0, right = n-1",
      "leftMax = rightMax = 0, water = 0",
      "while left < right:",
      "    if height[left] < height[right]:",
      "        if height[left] >= leftMax: leftMax = height[left]",
      "        else water += leftMax - height[left]",
      "        left++",
      "    else:",
      "        if height[right] >= rightMax: rightMax = height[right]",
      "        else water += rightMax - height[right]",
      "        right--",
      "return water",
    ],
    difficulty: "intermediate",
    effort: "Medium–High",
    tags: ["Two Pointers", "Greedy", "Array"],
  },
  "max-sum-subarray-k": {
    id: "max-sum-subarray-k",
    name: "Maximum Sum Subarray of Size K",
    category: "array",
    description:
      "Find the maximum sum of any contiguous subarray of size K using the sliding window technique.",
    shortDescription: "Fixed-size sliding window for max sum.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "compute sum of first k elements",
      "maxSum = currentSum",
      "for i from k to n-1:",
      "    currentSum += arr[i] - arr[i-k]",
      "    maxSum = max(maxSum, currentSum)",
      "return maxSum",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Sliding Window", "Array"],
  },
  "longest-substring-without-repeat": {
    id: "longest-substring-without-repeat",
    name: "Longest Substring Without Repeating Characters",
    category: "string",
    description:
      "Maintain a sliding window and a set/map of characters to find the longest substring with unique characters.",
    shortDescription: "Dynamic sliding window for unique substring.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(K) (alphabet size)",
    },
    pseudocode: [
      "set left = 0, maxLen = 0",
      "use set or map to track chars",
      "for right from 0 to n-1:",
      "    while char at right in set:",
      "        remove char at left, left++",
      "    add char at right to set",
      "    maxLen = max(maxLen, right-left+1)",
      "return maxLen",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Sliding Window", "String", "Hashing"],
  },
  "min-window-substring": {
    id: "min-window-substring",
    name: "Minimum Window Substring",
    category: "string",
    description:
      "Find the smallest substring of s that contains all characters of t. Use sliding window with character frequency counting.",
    shortDescription: "Sliding window with frequency map.",
    complexities: {
      best: "O(N + M)",
      average: "O(N + M)",
      worst: "O(N + M)",
      space: "O(K) (alphabet size)",
    },
    pseudocode: [
      "create map of target char counts",
      "set left = 0, have = 0, need = unique chars in target",
      "for right from 0 to n-1:",
      "    include s[right] in window",
      "    if window char count matches target → have++",
      "    while have == need:",
      "        update min window",
      "        pop from left and update counts",
      "return min window substring",
    ],
    difficulty: "advanced",
    effort: "High",
    tags: ["Sliding Window", "String", "Hashing", "Two Pointers"],
  },
  "sliding-window-median": {
    id: "sliding-window-median",
    name: "Sliding Window Median",
    category: "array",
    description:
      "Maintain a sliding window of size k and compute the median at each step using two heaps (max heap + min heap).",
    shortDescription: "Sliding window with heaps to find medians.",
    complexities: {
      best: "O(N log K)",
      average: "O(N log K)",
      worst: "O(N log K)",
      space: "O(K)",
    },
    pseudocode: [
      "initialize two heaps (maxHeap for left, minHeap for right)",
      "for each element i:",
      "    insert nums[i] into correct heap",
      "    balance heaps",
      "    if window size > k → remove nums[i-k]",
      "    if window size == k → record median",
      "return list of medians",
    ],
    difficulty: "advanced",
    effort: "High",
    tags: ["Sliding Window", "Heap", "Median", "Two Heaps"],
  },
  dfs: {
    id: "dfs",
    name: "Depth-First Search (DFS)",
    category: "graph",
    description:
      "Depth-First Search explores as far as possible along one branch before backtracking.",
    shortDescription: "Explores deep paths before backtracking.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function DFS(graph, start):",
      "   visited = set()",
      "   stack = [start]",
      "   while stack is not empty:",
      "       node = stack.pop()",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   stack.push(neighbor)",
    ],
    href: "/learn/pathfinding?algorithm=dfs",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Graph Traversal", "Stack", "Recursion"],
  },
  bfs: {
    id: "bfs",
    name: "Breadth-First Search (BFS)",
    category: "graph",
    description:
      "Breadth-First Search explores the graph level by level. It visits all neighbors before moving deeper.",
    shortDescription: "Explores graph level by level.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function BFS(graph, start):",
      "   visited = set()",
      "   queue = [start]",
      "   while queue is not empty:",
      "       node = queue.pop(0)",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   queue.append(neighbor)",
    ],
    href: "/learn/pathfinding?algorithm=bfs",
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Graph Traversal", "Queue", "Shortest Path"],
  },
};
