export interface AlgorithmMeta {
  id: string;
  name: string;
  category: string;
  description: string;
  shortDescription: string;
  complexities: {
    best: string;
    average: string;
    worst: string;
    space: string;
  };
  pseudocode?: string[];
  featured?: boolean;
  href?: string;
  tags?: string[];
  difficulty?: "beginner" | "intermediate" | "advanced";
  effort?: string;
}

export const algorithms: Record<string, AlgorithmMeta> = {
  "bubble-sort": {
    id: "bubble-sort",
    name: "Bubble Sort",
    category: "sorting",
    description:
      "Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It continues until the array is sorted.",
    shortDescription: "Simple sort by swapping adjacent elements.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "set n = length of array",
      "repeat until no swaps:",
      "    for i from 0 to n-2:",
      "        if arr[i] > arr[i+1]:",
      "           swap(arr[i], arr[i+1])",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=bubble-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Stable"],
  },
  "selection-sort": {
    id: "selection-sort",
    name: "Selection Sort",
    category: "sorting",
    description:
      "Selection Sort repeatedly selects the smallest element from the unsorted portion and swaps it with the first unsorted element, expanding the sorted portion one step at a time.",
    shortDescription: "Repeatedly selects the smallest element.",
    complexities: {
      best: "O(N²)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "set n = length of array",
      "for i from 0 to n-1:",
      "    set minIndex = i",
      "    for j from i+1 to n-1:",
      "        if arr[j] < arr[minIndex]:",
      "           minIndex = j",
      "    swap(arr[i], arr[minIndex])",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=selection-sort",
    difficulty: "beginner",
    effort: "Low",
    tags: ["In-place", "Unstable"],
  },
  "insertion-sort": {
    id: "insertion-sort",
    name: "Insertion Sort",
    category: "sorting",
    description:
      "Insertion Sort builds the sorted array one element at a time by repeatedly inserting the current element into its correct position among the already-sorted elements.",
    shortDescription: "Builds sorted array one item at a time.",
    complexities: {
      best: "O(N)",
      average: "O(N²)",
      worst: "O(N²)",
      space: "O(1)",
    },
    pseudocode: [
      "set n = length of array",
      "for i from 1 to n-1:",
      "    key = arr[i]; j = i - 1",
      "    while j >= 0:",
      "       if arr[j] > key:",
      "         arr[j+1] = arr[j], j--",
      "    arr[j+1] = key",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=insertion-sort",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Stable", "Online"],
  },
  "merge-sort": {
    id: "merge-sort",
    name: "Merge Sort",
    category: "sorting",
    description:
      "Merge Sort is a divide-and-conquer algorithm. It recursively splits the array into halves, sorts each half, and then merges the sorted halves back together.",
    shortDescription: "Splits array and merges sorted halves.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N log N)",
      space: "O(N)",
    },
    pseudocode: [
      "function merge(arr, l, r):",
      "    if l >= r: return",
      "    mid = (l + r) // 2",
      "    mergeSort(arr, l, mid)",
      "    mergeSort(arr, mid + 1, r)",
      "    merged = []",
      "    i = l, j = mid + 1",
      "    while i <= mid and j <= r:",
      "        if arr[i] <= arr[j]:",
      "            merged.push(arr[i]); i++",
      "        else:",
      "            merged.push(arr[j]); j++",
      "    while i <= mid:",
      "        merged.push(arr[i]); i++",
      "    while j <= r:",
      "        merged.push(arr[j]); j++",
      "    copy merged back into arr[l..r]",
      "    return",
      "function mergeSort(arr):",
      "    mergeSort(arr, 0, n - 1)",
    ],
    href: "/learn/sorting?algorithm=merge-sort",
    difficulty: "intermediate",
    effort: "Medium–High",
    tags: ["Divide & Conquer", "Stable", "Recursion"],
    featured: true,
  },
  "quick-sort": {
    id: "quick-sort",
    name: "Quick Sort",
    category: "sorting",
    description:
      "Quick Sort is a divide-and-conquer algorithm. It picks a pivot and partitions the array around the pivot, recursively sorting the partitions.",
    shortDescription: "Divide-and-conquer sorting using a pivot.",
    complexities: {
      best: "O(N log N)",
      average: "O(N log N)",
      worst: "O(N²)",
      space: "O(log N)",
    },
    pseudocode: [
      "function quickSort(arr, left, right):",
      "    if left >= right: return",
      "    pivotIndex = partition(arr, left, right)",
      "    quickSort(arr, left, pivotIndex - 1)",
      "    quickSort(arr, pivotIndex + 1, right)",
      "end (array is sorted)",
    ],
    href: "/learn/sorting?algorithm=quick-sort",
    difficulty: "intermediate",
    effort: "High",
    tags: ["Divide & Conquer", "Recursion", "In-place"],
    featured: true,
  },
  "linear-search": {
    id: "linear-search",
    name: "Linear Search",
    category: "searching",
    description:
      "Linear Search scans each element in the array sequentially until the target is found or the end of the array is reached.",
    shortDescription: "Scans elements sequentially for target.",
    complexities: {
      best: "O(1)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function linearSearch(arr, target):",
      "    for i from 0 to n - 1:",
      "        if arr[i] == target:",
      "            return i",
      "    return -1",
    ],
    href: "/learn/searching?algorithm=linear-search",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Brute Force", "Sequential"],
  },
  "binary-search": {
    id: "binary-search",
    name: "Binary Search",
    category: "searching",
    description:
      "Binary Search repeatedly divides the search interval in half. It compares the target with the middle element and eliminates half of the array each step, until the element is found or the interval is empty.",
    shortDescription: "Halves search space to find target fast.",
    complexities: {
      best: "O(1)",
      average: "O(log N)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "function binarySearch(arr, target):",
      "    left = 0, right = n - 1",
      "    while left <= right:",
      "        mid = (left + right) / 2",
      "        if arr[mid] == target:",
      "            return mid",
      "        else if arr[mid] > target:",
      "            right = mid - 1",
      "        else:",
      "            left = mid + 1",
      "    return -1",
    ],
    href: "/learn/searching?algorithm=binary-search",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Divide & Conquer", "Efficient"],
    featured: true,
  },
  "find-min-max": {
    id: "find-min-max",
    name: "Find Min & Max",
    category: "array",
    description:
      "The Min-Max algorithm scans through the array once, keeping track of the smallest and largest elements seen so far. At each step, it compares the current element with the current min and max and updates them if necessary. This ensures both values are found in a single pass.",
    shortDescription: "Finds smallest and largest element in one scan.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function findMinMax(arr):",
      "    set min = arr[0], max = arr[0]",
      "    for i from 1 to n - 1:",
      "        if arr[i] < min: min = arr[i]",
      "        else if arr[i] > max: max = arr[i]",
      "    return (min, max)",
    ],
    href: "/learn/array?algorithm=find-min-max",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linear Scan", "Basic", "Array"],
    featured: false,
  },
  "reverse-array": {
    id: "reverse-array",
    name: "Reverse Array",
    category: "array",
    description:
      "Reverse Array swaps elements from both ends moving toward the center. It uses a two-pointer approach where one pointer starts at the beginning and another at the end, swapping until they meet. This reverses the array in-place.",
    shortDescription: "Reverses an array in-place using two pointers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function reverse(arr):",
      "    i = 0, j = n - 1",
      "    while i < j:",
      "        swap arr[i] and arr[j]",
      "        i++, j--",
      "    return arr",
    ],
    href: "/learn/array?algorithm=reverse-array",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Two Pointers", "In-place", "Array"],
  },
  "rotate-array": {
    id: "rotate-array",
    name: "Rotate Array by K steps",
    category: "array",
    description:
      "Rotate Array shifts elements in the array by a given number of steps. Each element is moved to a new position based on the rotation count, and the array is adjusted so that the order of elements wraps around. This results in the array being rotated to the left or right depending on the direction of rotation.",
    shortDescription: "Rotates an array by k steps, wrapping elements around.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function rotate(arr, k):",
      "    for r from 0 to k-1:",
      "        temp = arr[0]",
      "        for j from 1 to n-1:",
      "            arr[j-1] = arr[j]",
      "        arr[n-1] = temp",
      "    return arr",
    ],
    href: "/learn/array?algorithm=rotate-array",
    difficulty: "beginner",
    effort: "Medium",
    featured: true,
    tags: ["Array", "Rotation", "Two Pointers"],
  },
  kadane: {
    id: "kadane",
    name: "Kadane's Algorithm",
    category: "array",
    description:
      "Kadane's Algorithm finds the maximum sum of any contiguous subarray. It keeps track of a running sum (current sum) and resets it when it becomes worse than starting fresh. The best sum found so far is updated whenever the running sum is greater.",
    shortDescription: "Finds max sum of a contiguous subarray.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function kadane(arr):",
      "    n = length(arr)",
      "    sum = arr[0], max = arr[0]",
      "    for i from 1 to n-1:",
      "        if sum + arr[i] >= arr[i]:",
      "            sum = sum + arr[i]",
      "        else:",
      "            sum = arr[i]",
      "        if sum > max:",
      "            max = sum",
      "    return max",
    ],
    href: "/learn/array?algorithm=kadane",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Dynamic Programming", "Subarray", "Efficient"],
    featured: true,
  },
  "prefix-sum": {
    id: "prefix-sum",
    name: "Prefix Sum Array",
    category: "array",
    description:
      "Pre-compute cumulative sums of an array to answer range sum queries efficiently.",
    shortDescription: "Precomputes cumulative sums for fast queries.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N)",
    },
    difficulty: "beginner",
    effort: "Low–Medium",
  },
  "max-sum-subarray-k": {
    id: "max-sum-subarray-k",
    name: "Max Sum Subarray of Size K",
    category: "Sliding Window",
    description:
      "Find the maximum sum of any contiguous subarray of size k. This is the simplest and most common use case of a fixed-size sliding window.",
    shortDescription: "Compute max sum of all subarrays of fixed size k.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(1)",
    },
    pseudocode: [
      "function maxSumSubarrayK(arr, k):",
      "    sum = sum of first k elements",
      "    maxSum = sum",
      "    for right from k to n-1:",
      "       sum += arr[right] - arr[right-k]",
      "        if sum > maxSum:",
      "            maxSum = sum",
      "    return maxSum",
    ],
    featured: true,
    href: "/learn/sliding-window?algorithm=max-sum-subarray-k",
    tags: ["array", "sliding-window", "fixed-size"],
    difficulty: "beginner",
    effort: "Easy",
  },
  "smallest-subarray-with-sum-greater-than-k": {
    id: "smallest-subarray-with-sum-greater-than-k",
    name: "Smallest Subarray with Sum ≥ K",
    category: "Sliding Window",
    description:
      "Find the length of the smallest contiguous subarray whose sum is greater than or equal to K. This introduces the shrinking window pattern.",
    shortDescription: "Find minimum window length with sum ≥ K.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(1)",
    },
    pseudocode: [
      "function smallestSubWithSum(arr, k):",
      "    start = 0, currSum = 0, minLen = ∞",
      "    for end from 0 to n-1:",
      "        currSum += arr[end]",
      "        while currSum > k:",
      "            minLen = min(minLen, end - start + 1)",
      "            currSum -= arr[start]",
      "            start++",
      "    return minLen (or 0 if not found)",
    ],
    featured: false,
    href: "/learn/sliding-window?algorithm=smallest-subarray-with-sum-greater-than-k",
    tags: ["array", "sliding-window", "variable-size"],
    difficulty: "beginner",
    effort: "Easy",
  },
  "longest-substring-without-repeat": {
    id: "longest-substring-without-repeat",
    name: "Longest Substring Without Repeating Characters",
    category: "Sliding Window",
    description:
      "Find the length of the longest substring without any repeating characters. This introduces hash maps or sets to track window content dynamically.",
    shortDescription: "Find longest substring with all unique characters.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(min(n, charset))",
    },
    pseudocode: [
      "function longestUniqueSubstr(str):",
      "    start = 0, maxLen = 0, seen = {}",
      "    for end from 0 to n-1:",
      "        if str[end] in seen and seen[str[end]] >= start:",
      "            start = seen[str[end]] + 1",
      "        seen[str[end]] = end",
      "        if (end - start + 1) > maxLen:",
      "            maxLen = end - start + 1",
      "    return maxLen",
    ],
    featured: true,
    href: "/learn/sliding-window?algorithm=longest-substring-without-repeat",
    tags: ["string", "sliding-window", "hash-set"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  factorial: {
    id: "factorial",
    name: "Factorial (Stack View)",
    category: "recursion",
    description:
      "Factorial is defined recursively: n! = n × (n-1)! with base case 0! = 1. Recursion demonstrates the call stack as it unwinds.",
    shortDescription: "Compute factorial using recursion and stack frames.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function factorial(n):",
      "    if n == 0 or n == 1:",
      "        return 1",
      "    return n * factorial(n - 1)",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Recursion", "Stack", "Math"],
  },
  fibonacci: {
    id: "fibonacci",
    name: "Fibonacci (Recursion Tree)",
    category: "recursion",
    description:
      "Fibonacci numbers follow the recurrence F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. Recursive calls expand into a tree structure, illustrating exponential growth.",
    shortDescription: "Recursive definition of Fibonacci sequence.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function fib(n):",
      "    if n == 0: return 0",
      "    if n == 1: return 1",
      "    return fib(n - 1) + fib(n - 2)",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "Tree", "Math"],
  },
  "sum-n": {
    id: "sum-n",
    name: "Sum of First N Numbers",
    category: "recursion",
    description:
      "Sum of the first N natural numbers using recursion: S(n) = n + S(n-1), with base case S(0) = 0.",
    shortDescription: "Recursive summation of first N numbers.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function sumN(n):",
      "    if n == 0:",
      "        return 0",
      "    return n + sumN(n - 1)",
    ],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Recursion", "Math", "Pattern"],
  },
  "tower-of-hanoi": {
    id: "tower-of-hanoi",
    name: "Tower of Hanoi",
    category: "recursion",
    description:
      "Tower of Hanoi is a classic puzzle solved recursively: move n-1 disks to auxiliary, move the largest disk to target, then move n-1 disks from auxiliary to target.",
    shortDescription: "Recursive disk-moving puzzle solution.",
    complexities: {
      best: "O(2^N)",
      average: "O(2^N)",
      worst: "O(2^N)",
      space: "O(N) (recursion stack)",
    },
    pseudocode: [
      "function hanoi(n, source, target, auxiliary):",
      "    if n == 1:",
      "        move disk from source → target",
      "        return",
      "    hanoi(n-1, source, auxiliary, target)",
      "    move disk from source → target",
      "    hanoi(n-1, auxiliary, target, source)",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Recursion", "Puzzle", "Divide & Conquer"],
  },
  "reverse-string": {
    id: "reverse-string",
    name: "Reverse String (Recursive)",
    category: "recursion",
    description:
      "Reverse a string recursively by reducing the problem: reverse the substring after the first character, then append the first character to the result.",
    shortDescription: "Recursively reverse a string.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(N) (recursion stack + new string)",
    },
    pseudocode: [
      "function reverse(s):",
      "    if length of s <= 1:",
      "        return s",
      "    return reverse(s[1:]) + s[0]",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Recursion", "String", "Divide & Conquer"],
  },
  "check-odd-even": {
    id: "check-odd-even",
    name: "Check if Number is Odd or Even",
    category: "bitmask",
    description:
      "Use bitwise AND with 1 to check if a number is odd or even. If the least significant bit is 1, the number is odd; otherwise, it is even.",
    shortDescription: "Check odd/even using least significant bit.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function checkOddEven(n):",
      "    look at the least significant bit (n & 1)",
      "    if (n & 1) == 1:",
      "        return 'odd'",
      "    else:",
      "        return 'even'",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=check-odd-even",
    tags: ["Bits", "Odd/Even", "Trick"],
  },
  "get-ith-bit": {
    id: "get-ith-bit",
    name: "Get i-th Bit",
    category: "bitmask",
    description:
      "Check if the i-th bit of a number is set (1) or not (0) using a mask.",
    shortDescription: "Check if i-th bit is 1.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function getIthBit(n, i):",
      "    mask = 1 << i",
      "    if (n & mask) != 0:",
      "        return true",
      "    else:",
      "        return false",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=get-ith-bit",
    tags: ["Bits", "Masking", "Check"],
  },
  "set-ith-bit": {
    id: "set-ith-bit",
    name: "Set i-th Bit",
    category: "bitmask",
    description: "Turn the i-th bit of a number to 1 using OR with a mask.",
    shortDescription: "Force i-th bit to 1.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function setIthBit(n, i):",
      "    mask = 1 << i",
      "    n = n | mask",
      "    return n",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=set-ith-bit",
    tags: ["Bits", "Masking", "Set"],
  },
  "clear-ith-bit": {
    id: "clear-ith-bit",
    name: "Clear i-th Bit",
    category: "bitmask",
    description:
      "Turn the i-th bit of a number to 0 using AND with the inverse of a mask.",
    shortDescription: "Force i-th bit to 0.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function clearIthBit(n, i):",
      "    mask = 1 << i",
      "    mask = ~mask",
      "    n = n & mask",
      "    return n",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=clear-ith-bit",
    tags: ["Bits", "Masking", "Clear"],
  },
  "toggle-ith-bit": {
    id: "toggle-ith-bit",
    name: "Toggle i-th Bit",
    category: "bitmask",
    description: "Flip the i-th bit of a number using XOR with a mask.",
    shortDescription: "Flip i-th bit (0→1 or 1→0).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function toggleIthBit(n, i):",
      "    mask = 1 << i",
      "    n = n ^ mask",
      "    return n",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=toggle-ith-bit",
    tags: ["Bits", "Masking", "Toggle"],
  },
  "count-set-bits": {
    id: "count-bits",
    name: "Count Set Bits",
    category: "bitmask",
    description:
      "Count the number of 1 bits in an integer using Brian Kernighan’s algorithm: repeatedly clear the lowest set bit until the number becomes zero.",
    shortDescription: "Count 1s in binary representation.",
    complexities: {
      best: "O(k), k = set bits",
      average: "O(k)",
      worst: "O(log N)",
      space: "O(1)",
    },
    pseudocode: [
      "function countSetBits(n):",
      "    count = 0",
      "    while n > 0:",
      "        if (n & 1) == 1:",
      "            count++",
      "        n = n >> 1",
      "    return count",
    ],
    difficulty: "intermediate",
    href: "/learn/bitmask?algorithm=count-set-bits",
    effort: "Medium",
    tags: ["Bits", "Kernighan", "Counting"],
  },
  "power-of-two": {
    id: "power-of-two",
    name: "Check if Number is Power of Two",
    category: "bitmask",
    description:
      "A number is a power of two if it has exactly one set bit. This can be checked with n > 0 and n & (n-1) == 0.",
    shortDescription: "Check power-of-two using bit trick.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: [
      "function powerOfTwo(n):",
      "    if (n & (n - 1)) == 0 and n > 0:",
      "        return true",
      "    else:",
      "        return false",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/bitmask?algorithm=power-of-two",
    tags: ["Bits", "Power of Two", "Trick"],
  },
  "lowest-set-bit": {
    id: "lowest-set-bit",
    name: "Get Lowest Set Bit",
    category: "bitmask",
    description:
      "Extract the lowest set bit of a number using the expression n & -n. Useful in Fenwick trees and subset generation.",
    shortDescription: "Isolate lowest set bit using n & -n.",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["lowest = n & -n"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Trick", "Lowest Bit"],
  },
  "clear-lowest-set-bit": {
    id: "clear-lowest-set-bit",
    name: "Clear Lowest Set Bit",
    category: "bitmask",
    description:
      "Clear the lowest set bit of a number using n & (n-1). Commonly used for iterating through subsets efficiently.",
    shortDescription: "Clear lowest set bit using n & (n-1).",
    complexities: {
      best: "O(1)",
      average: "O(1)",
      worst: "O(1)",
      space: "O(1)",
    },
    pseudocode: ["n = n & (n - 1)"],
    difficulty: "beginner",
    effort: "Low",
    tags: ["Bits", "Subset Iteration", "Trick"],
  },
  subsets: {
    id: "subsets",
    name: "Subsets (Power Set)",
    category: "Backtracking",
    description:
      "Generate all possible subsets (the power set) of a given array using recursion and backtracking.",
    shortDescription: "Generate all subsets of an array.",
    complexities: {
      best: "O(2^n)",
      average: "O(2^n)",
      worst: "O(2^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(start, path):",
      "    add copy of path to result",
      "    for i from start to n-1:",
      "        path.push(nums[i])",
      "        backtrack(i + 1, path)",
      "        path.pop()",
      "function subsets(nums):",
      "    result = []",
      "    backtrack(0, [])",
      "    return result",
    ],
    featured: true,
    href: "/learn/backtracking?algorithm=subsets",
    tags: ["array", "backtracking", "recursion", "power-set"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  permutations: {
    id: "permutations",
    name: "Permutations",
    category: "Backtracking",
    description:
      "Generate all possible permutations of a given array using recursion and backtracking.",
    shortDescription: "Generate all permutations of an array.",
    complexities: {
      best: "O(n!)",
      average: "O(n!)",
      worst: "O(n!)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(path, used):",
      "    if path.length == n:",
      "        add copy of path to result",
      "        return",
      "    for i in 0..n-1:",
      "        if used[i]: continue",
      "        path.push(nums[i]); used[i] = true",
      "        backtrack(path, used)",
      "        path.pop(); used[i] = false",
      "function permutations(nums):",
      "    result = []",
      "    backtrack([], [false]*n)",
      "    return result",
    ],
    featured: true,
    href: "/learn/backtracking?algorithm=permutations",
    tags: ["array", "backtracking", "recursion", "permutations"],
    difficulty: "intermediate",
    effort: "Medium–High",
  },
  "combination-sum": {
    id: "combination-sum",
    name: "Combination Sum",
    category: "Backtracking",
    description:
      "Find all unique combinations of candidates where the chosen numbers sum to a target. Numbers can be reused multiple times.",
    shortDescription: "Generate all combinations with sum = target.",
    complexities: {
      best: "O(2^n)",
      average: "O(2^n)",
      worst: "O(2^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(start, remaining, path):",
      "    if remaining == 0:",
      "        add copy of path to result",
      "        return",
      "    for i in range(start, n):",
      "        if arr[i] > remaining: break",
      "        path.push(arr[i])",
      "        backtrack(i, remaining - arr[i], path)",
      "        path.pop()",
      "function combinationSum(arr, target):",
      "    result = []",
      "    backtrack(0, target, [])",
      "    return result",
    ],
    featured: false,
    href: "/learn/backtracking?algorithm=combination-sum",
    tags: ["array", "backtracking", "recursion", "pruning"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  "n-queens": {
    id: "n-queens",
    name: "N-Queens",
    category: "Backtracking",
    description:
      "Place N queens on an N×N chessboard so that no two queens threaten each other. Classic constraint-satisfaction problem.",
    shortDescription: "Place N queens on the board safely.",
    complexities: {
      best: "O(N!)",
      average: "O(N!)",
      worst: "O(N!)",
      space: "O(N)",
    },
    pseudocode: [
      "result = []",
      "function backtrack(row, columns, diag1, diag2, board):",
      "    if row == N:",
      "        result.push(board.copy())",
      "        return",
      "    for col from 0 to N - 1:",
      "        if col in columns or row+col in diag1 or row-col in diag2: continue",
      "        placeQueen(row, col)",
      "        backtrack(row + 1, columns ∪ col, diag1 ∪ (row+col), diag2 ∪ (row-col), board)",
      "        removeQueen(row, col)",
      "backtrack(0, {}, {}, {}, emptyBoard)",
      "return result",
    ],
    featured: true,
    tags: ["matrix", "backtracking", "recursion", "constraints"],
    difficulty: "intermediate",
    effort: "High",
  },
  "word-search": {
    id: "word-search",
    name: "Word Search",
    category: "Backtracking",
    description:
      "Search for a word in a 2D grid by moving horizontally or vertically. Each letter cell can only be used once per word.",
    shortDescription: "Find if a word exists in a grid.",
    complexities: {
      best: "O(N*M*L)",
      average: "O(N*M*L)",
      worst: "O(N*M*4^L)",
      space: "O(L)",
    },
    pseudocode: [
      "function dfs(r, c, index):",
      "    if index == len(word): return true",
      "    if out of bounds or board[r][c] != word[index]: return false",
      "    mark board[r][c] as visited",
      "    for each direction in [up, down, left, right]:",
      "        if dfs(r+dr, c+dc, index+1): return true",
      "    unmark board[r][c]",
      "    return false",
      "for each cell in board:",
      "    if dfs(r, c, 0): return true",
      "return false",
    ],
    featured: false,
    tags: ["matrix", "backtracking", "dfs"],
    difficulty: "intermediate",
    effort: "Medium",
  },
  "sudoku-solver": {
    id: "sudoku-solver",
    name: "Sudoku Solver",
    category: "Backtracking",
    description:
      "Fill a 9×9 Sudoku board so that every row, column, and 3×3 sub-box contains digits 1 to 9 without repetition.",
    shortDescription: "Solve Sudoku using backtracking.",
    complexities: {
      best: "O(1)",
      average: "O(9^m)",
      worst: "O(9^m)",
      space: "O(m)",
    },
    pseudocode: [
      "function solve():",
      "    for each cell (r, c):",
      "        if board[r][c] is empty:",
      "            for d from 1 to 9:",
      "                if d is valid in row, col, box:",
      "                    place d",
      "                    if solve(): return true",
      "                    remove d",
      "            return false",
      "    return true",
      "solve()",
    ],
    featured: false,
    tags: ["matrix", "backtracking", "constraint-satisfaction"],
    difficulty: "advanced",
    effort: "Very High",
  },
  "letter-combinations-phone": {
    id: "letter-combinations-phone",
    name: "Letter Combinations of a Phone Number",
    category: "Backtracking",
    description:
      "Given a string of digits from 2-9, return all possible letter combinations based on phone keypad mappings.",
    shortDescription: "Generate letter combinations for phone digits.",
    complexities: {
      best: "O(4^n)",
      average: "O(4^n)",
      worst: "O(4^n)",
      space: "O(n)",
    },
    pseudocode: [
      "function backtrack(index, path):",
      "    if index == len(digits):",
      "        add path to result",
      "        return",
      "    digit = digits[index]",
      "    letters = phoneMap[digit]",
      "    for each letter in letters:",
      "        path.push(letter)",
      "        backtrack(index + 1, path)",
      "        path.pop()",
      "function letterCombinations(digits):",
      "    if digits is empty: return []",
      "    backtrack(0, [])",
      "    return result",
    ],
    featured: false,
    href: "/learn/backtracking?algorithm=letter-combinations-phone",
    tags: ["string", "backtracking", "recursion"],
    difficulty: "beginner",
    effort: "Easy–Medium",
  },
  "ll-insert-end": {
    id: "ll-insert-end",
    name: "Insert at End (Singly List)",
    category: "linkedlist",
    description:
      "Given only the head pointer, traverse to the tail and attach a new node there. This runs in O(N).",
    shortDescription: "Traverse to tail and link new node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function insertAtEnd(head, value):",
      "    if head is null: return new Node(value)",
      "    curr = head",
      "    while curr.next is not null:",
      "        curr = curr.next",
      "    newNode = new Node(value)",
      "    curr.next = newNode",
      "    return head",
    ],
    href: "/learn/list?algorithm=ll-insert-end",
    difficulty: "beginner",
    effort: "Low–Medium",
    tags: ["Linked List", "Singly", "Pointers", "Insertion"],
  },
  "ll-reverse": {
    id: "ll-reverse",
    name: "Reverse a Linked List (Singly)",
    category: "linkedlist",
    description:
      "Reverse the order of nodes in a singly linked list by re-wiring each node’s next pointer.",
    shortDescription: "Reverse a singly linked list in-place.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function reverseList(head):",
      "    prev = null",
      "    curr = head",
      "    while curr is not null:",
      "        next = curr.next",
      "        curr.next = prev",
      "        prev = curr",
      "        curr = next",
      "    head = prev",
      "    return head",
    ],
    href: "/learn/list?algorithm=ll-reverse",
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Reversal"],
  },
  "ll-cycle-detect-floyd": {
    id: "ll-cycle-detect-floyd",
    name: "Cycle Detection (Floyd's Algorithm)",
    category: "linkedlist",
    description:
      "Detect whether a cycle exists in a singly linked list using Floyd’s cycle-finding algorithm (tortoise and hare).",
    shortDescription: "Use two pointers (slow/fast) to detect a cycle.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function hasCycle(head):",
      "    slow = head",
      "    fast = head",
      "    while fast != null and fast.next != null:",
      "        slow = slow.next",
      "        fast = fast.next.next",
      "        if slow == fast:",
      "            return true",
      "    return false",
    ],
    href: "/learn/list?algorithm=ll-cycle-detect-floyd",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Pointers", "Cycle Detection", "Floyd"],
    featured: true,
  },
  "ll-merge-two-sorted": {
    id: "ll-merge-two-sorted",
    name: "Merge Two Sorted Lists (Singly)",
    category: "linkedlist",
    description:
      "Given two singly linked lists sorted in ascending order, merge them into a single sorted list by rearranging pointers in-place.",
    shortDescription: "Merge two sorted linked lists in-place.",
    complexities: {
      best: "O(N + M)",
      average: "O(N + M)",
      worst: "O(N + M)",
      space: "O(1)",
    },
    pseudocode: [
      "function mergeTwoSorted(head1, head2):",
      "    if head1 == null: return head2",
      "    if head2 == null: return head1",
      "    prev1 = null; curr1 = head1; curr2 = head2",
      "    while curr1 != null and curr2 != null:",
      "        if curr1.value <= curr2.value:",
      "            prev1 = curr1",
      "            curr1 = curr1.next",
      "        else:",
      "            link prev1 to curr2",
      "            head1 = curr2 if prev1 == null",
      "            next2 = curr2.next",
      "            curr2.next = curr1",
      "            prev1 = curr2",
      "            curr2 = next2",
      "    if curr2 != null:",
      "        prev1.next = curr2",
      "    return head1",
    ],
    href: "/learn/list?algorithm=ll-merge-two-sorted",
    difficulty: "intermediate",
    effort: "Medium",
    tags: ["Linked List", "Singly", "Merge", "Two Pointers"],
  },
  "ll-middle-node": {
    id: "ll-middle-node",
    name: "Find Middle Node (Singly)",
    category: "linkedlist",
    description:
      "Find the middle node of a singly linked list using the slow–fast pointer technique.",
    shortDescription: "Use slow–fast pointers to find the middle node.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function findMiddleNode(head):",
      "    slow = head",
      "    fast = head",
      "    while fast != null and fast.next != null:",
      "        slow = slow.next",
      "        fast = fast.next.next",
      "    return slow",
      "end (slow is the middle node)",
    ],
    href: "/learn/list?algorithm=ll-middle-node",
    difficulty: "beginner",
    effort: "Low",
    tags: ["Linked List", "Singly", "Pointers", "Slow-Fast"],
  },
  "two-sum-sorted": {
    id: "two-sum-sorted",
    name: "Two Sum (Sorted Array)",
    category: "array",
    description:
      "Find two numbers in a sorted array that add up to a target using the two-pointer technique. One pointer starts at the beginning and the other at the end, moving inward until the pair is found.",
    shortDescription: "Two pointers to find target sum in sorted array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function twoSum(arr, target):",
      "    left = 0, right = arr.length - 1",
      "    while left < right:",
      "        sum = arr[left] + arr[right]",
      "        if sum == target:",
      "            return [arr[left], arr[right]]",
      "        else if sum < target:",
      "            left++",
      "        else:",
      "            right--",
      "    return not found",
    ],
    difficulty: "beginner",
    effort: "Low",
    href: "/learn/two-pointers?algorithm=two-sum-sorted",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "three-sum": {
    id: "three-sum",
    name: "Three Sum",
    category: "array",
    description:
      "Find three numbers in a sorted array that add up to a target using the two-pointer technique. Fix one element, then apply the two-pointer method on the remaining subarray to find a triplet.",
    shortDescription:
      "Fix one element, then use two pointers to find a triplet sum.",
    complexities: {
      best: "O(N^2)",
      average: "O(N^2)",
      worst: "O(N^2)",
      space: "O(1)",
    },
    pseudocode: [
      "function threeSum(arr, target):",
      "    for i from 0 to n-3:",
      "        left = i+1, right = n-1",
      "        while left < right:",
      "            sum = arr[i] + arr[left] + arr[right]",
      "            if sum == target:",
      "                return [arr[i], arr[left], arr[right]]",
      "            else if sum < target:",
      "                left++",
      "            else:",
      "                right--",
      "    return not found",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    href: "/learn/two-pointers?algorithm=three-sum",
    tags: ["Two Pointers", "Array", "Search"],
  },
  "move-zeroes": {
    id: "move-zeroes",
    name: "Move Zeroes",
    category: "array",
    description:
      "Rearrange the array so that all zero elements are shifted to the end while maintaining the order of non-zero elements.",
    shortDescription: "Shift all zeroes to the end of the array.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function moveZeroes(arr):",
      "    lastNonZero = 0",
      "    for i from 0 to n-1:",
      "        if arr[i] != 0:",
      "            swap arr[i], arr[lastNonZero]",
      "            lastNonZero++",
      "        else:",
      "            continue",
      "    return arr",
    ],
    difficulty: "beginner",
    effort: "Low–Medium",
    href: "/learn/two-pointers?algorithm=move-zeroes",
  },
  "container-most-water": {
    id: "container-most-water",
    name: "Container With Most Water",
    category: "array",
    description:
      "Given heights, use two pointers at both ends and move the smaller height inward to maximize water area.",
    shortDescription: "Two pointers to maximize area between heights.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function mostWater(heights):",
      "    left = 0, right = n - 1, maxArea = 0",
      "    while left < right:",
      "        area = min(heights[left], heights[right])",
      "              * (right - left)",
      "        update maxArea if area is larger",
      "        if heights[left] < heights[right]:",
      "            left++",
      "        else:",
      "            right--",
      "    return maxArea",
    ],
    difficulty: "intermediate",
    effort: "Medium",
    href: "/learn/two-pointers?algorithm=container-most-water",
    tags: ["Two Pointers", "Greedy", "Optimization"],
  },
  "trap-rain-water": {
    id: "trap-rain-water",
    name: "Trapping Rain Water",
    category: "array",
    description:
      "Compute trapped water by maintaining two pointers and keeping track of left max and right max boundaries.",
    shortDescription: "Two pointers with left/right max tracking.",
    complexities: {
      best: "O(N)",
      average: "O(N)",
      worst: "O(N)",
      space: "O(1)",
    },
    pseudocode: [
      "function trapWater(heights):",
      "    left = 1, right = n - 2",
      "    leftMax = heights[0], rightMax = heights[n-1]",
      "    water = 0",
      "    while left <= right:",
      "        if leftMax <= rightMax:",
      "            if heights[left] >= leftMax:",
      "                leftMax = heights[left]",
      "            else:",
      "                water += leftMax - heights[left]",
      "            left++",
      "        else:",
      "            if heights[right] >= rightMax:",
      "                rightMax = heights[right]",
      "            else:",
      "                water += rightMax - heights[right]",
      "            right--",
      "    return water",
    ],
    difficulty: "advanced",
    effort: "Medium–High",
    href: "/learn/two-pointers?algorithm=trap-rain-water",
    tags: ["Two Pointers", "Greedy", "Array"],
  },
  "merge-intervals": {
    id: "merge-intervals",
    name: "Merge Intervals",
    category: "Intervals",
    description:
      "Given a collection of intervals, merge all overlapping intervals into non-overlapping intervals that cover the same ranges.",
    shortDescription: "Merge overlapping intervals into consolidated ranges.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n) for output",
    },
    pseudocode: [
      "sort intervals by start time",
      "initialize merged list",
      "for each interval:",
      "    if merged is empty or current.start > last.end:",
      "        append interval to merged",
      "    else:",
      "        merge with last interval (update last.end)",
      "return merged",
    ],
    difficulty: "beginner",
    effort: "low",
    href: "/learn/intervals?algorithm=merge-intervals",
    tags: ["greedy", "sorting", "intervals"],
  },
  "insert-interval": {
    id: "insert-interval",
    name: "Insert Interval",
    category: "Intervals",
    description:
      "Insert a new interval into a list of non-overlapping sorted intervals, merging if necessary.",
    shortDescription:
      "Insert and merge a new interval into existing sorted intervals.",
    complexities: {
      best: "O(n)",
      average: "O(n)",
      worst: "O(n)",
      space: "O(n) for output",
    },
    pseudocode: [
      "sort intervals by start time",
      "initialize merged list",
      "for interval in intervals:",
      "    if interval.end < new.start:",
      "        add interval to result",
      "    else if interval.start > new.end:",
      "        add new interval, then remaining intervals",
      "    else:",
      "        merge interval with new (update start/end)",
      "add new interval",
      "return merged",
    ],
    difficulty: "intermediate",
    effort: "medium",
    href: "/learn/intervals?algorithm=insert-interval",
    tags: ["greedy", "sorting", "intervals"],
  },
  "non-overlapping-intervals": {
    id: "non-overlapping-intervals",
    name: "Non-overlapping Intervals",
    category: "Intervals",
    description:
      "Find the minimum number of intervals to remove so that the rest are non-overlapping.",
    shortDescription: "Remove minimum intervals to eliminate overlaps.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(1)",
    },
    pseudocode: [
      "sort intervals by end time",
      "end = -∞",
      "for interval in intervals:",
      "    if interval.start >= end:",
      "        end = interval.end",
      "    else:",
      "        remove interval",
      "return original",
    ],
    difficulty: "intermediate",
    effort: "medium",
    href: "/learn/intervals?algorithm=non-overlapping-intervals",
    tags: ["greedy", "sorting", "intervals"],
  },
  "meeting-rooms-ii": {
    id: "meeting-rooms-ii",
    name: "Meeting Rooms II",
    category: "Intervals",
    description:
      "Given meeting time intervals, find the minimum number of conference rooms required.",
    shortDescription:
      "Find minimum meeting rooms needed for overlapping intervals.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "sort start times and end times",
      "rooms = 0, endPtr = 0",
      "for each start time:",
      "    if start < end[endPtr]:",
      "        rooms++",
      "    else:",
      "        endPtr++",
      "return rooms",
    ],
    difficulty: "advanced",
    effort: "high",
    href: "/learn/intervals?algorithm=meeting-rooms-ii",
    tags: ["heap", "sweep-line", "intervals"],
  },
  "employee-free-time": {
    id: "employee-free-time",
    name: "Employee Free Time",
    category: "Intervals",
    description:
      "Given employees' schedules (lists of working intervals), return the common free time intervals across all employees.",
    shortDescription:
      "Find gaps between merged busy intervals to get free time.",
    complexities: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      space: "O(n)",
    },
    pseudocode: [
      "collect all intervals from all employees",
      "sort intervals by start time",
      "curr = first interval",
      "for each interval in intervals[1:]:",
      "    if interval.start <= curr.end:",
      "        curr.end = max(curr.end, interval.end)",
      "    else:",
      "        add curr to merged",
      "        record free time [curr.end, interval.start]",
      "        curr = interval",
      "add curr to merged",
      "return merged and free times",
    ],
    difficulty: "advanced",
    effort: "high",
    href: "/learn/intervals?algorithm=employee-free-time",
    tags: ["intervals", "merge", "scheduling"],
  },
  dfs: {
    id: "dfs",
    name: "Depth-First Search (DFS)",
    category: "graph",
    description:
      "Depth-First Search explores as far as possible along one branch before backtracking.",
    shortDescription: "Explores deep paths before backtracking.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function DFS(graph, start):",
      "   visited = set()",
      "   stack = [start]",
      "   while stack is not empty:",
      "       node = stack.pop()",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   stack.push(neighbor)",
    ],
    difficulty: "intermediate",
    effort: "medium",
    tags: ["Graph Traversal", "Stack", "Recursion"],
  },
  bfs: {
    id: "bfs",
    name: "Breadth-First Search (BFS)",
    category: "graph",
    description:
      "Breadth-First Search explores the graph level by level. It visits all neighbors before moving deeper.",
    shortDescription: "Explores graph level by level.",
    complexities: {
      best: "O(V + E)",
      average: "O(V + E)",
      worst: "O(V + E)",
      space: "O(V)",
    },
    pseudocode: [
      "function BFS(graph, start):",
      "   visited = set()",
      "   queue = [start]",
      "   while queue is not empty:",
      "       node = queue.pop(0)",
      "       if node not in visited:",
      "           mark node as visited",
      "           for neighbor in graph[node]:",
      "               if neighbor not in visited:",
      "                   queue.append(neighbor)",
    ],
    difficulty: "beginner",
    effort: "Medium",
    tags: ["Graph Traversal", "Queue", "Shortest Path"],
  },
};
